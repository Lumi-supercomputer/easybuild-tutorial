{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Warning (Apr 19th 2020) This is very much a work in progress! Many pages are still empty, that will hopefully change soon... Welcome to the official EasyBuild tutorial! \u00b6 Scope \u00b6 This is an introductory tutorial to EasyBuild , a command line tool for installing (scientific) software on High Performance Computing (HPC) systems. It aims to explain the core concepts of EasyBuild, get you started with using it, make you familiar with some of the features it provides, and show how it is used by large HPC sites to maintain their central software stacks. Through hands-on exercises and demos, you will learn how EasyBuild can help you to get scientific software installed in an efficient way. Intended audience \u00b6 This tutorial is primarily intended for people new to EasyBuild, but even if you're already familiar with the project it could be interesting to step through it. Our main target audience includes: HPC system administrators HPC user support team members scientific researchers using HPC systems Prerequisites \u00b6 We expect you to be (a little bit) familiar with: using a Linux command line interface the (absolute) basics of compiling software from source Required software: OS: GNU/Linux (any distribution) Python 2.7 or 3.5+ an environment modules tool (see the module command) we recommend Lmod , a modern environment modules tool implemented in Lua for more information on the environment modules tools supported by EasyBuild, see here Practical information \u00b6 For the sake of this tutorial, you can: use the #tutorial channel in the EasyBuild Slack for asking questions or getting help; use AWS Cloud9 for the hands-on exercises; use the prepared container image through Docker or Singularity; Please see this page for more details. Tutorial contents \u00b6 Introduction to EasyBuild Installation (*) Configuration (*) Basic usage (*) Troubleshooting (*) Beyond the basics (*) Hierarchical module naming schemes (*) Adding support for additional software (*) EasyBuild at J\u00fclich Supercomputing Centre EasyBuild at Compute Canada The EasyBuild Community Contributing to EasyBuild (*) Comparison with other tools Getting help (sections indicated with (*) involve hands-on exercises) Additional resources \u00b6 website: https://easybuilders.github.io/easybuild documentation: https://easybuild.readthedocs.io GitHub: https://github.com/easybuilders Slack: https://easybuild.slack.com (self-request an invite here ) mailing list: https://lists.ugent.be/wws/subscribe/easybuild","title":""},{"location":"#welcome-to-the-official-easybuild-tutorial","text":"","title":"Welcome to the official EasyBuild tutorial!"},{"location":"#scope","text":"This is an introductory tutorial to EasyBuild , a command line tool for installing (scientific) software on High Performance Computing (HPC) systems. It aims to explain the core concepts of EasyBuild, get you started with using it, make you familiar with some of the features it provides, and show how it is used by large HPC sites to maintain their central software stacks. Through hands-on exercises and demos, you will learn how EasyBuild can help you to get scientific software installed in an efficient way.","title":"Scope"},{"location":"#intended-audience","text":"This tutorial is primarily intended for people new to EasyBuild, but even if you're already familiar with the project it could be interesting to step through it. Our main target audience includes: HPC system administrators HPC user support team members scientific researchers using HPC systems","title":"Intended audience"},{"location":"#prerequisites","text":"We expect you to be (a little bit) familiar with: using a Linux command line interface the (absolute) basics of compiling software from source Required software: OS: GNU/Linux (any distribution) Python 2.7 or 3.5+ an environment modules tool (see the module command) we recommend Lmod , a modern environment modules tool implemented in Lua for more information on the environment modules tools supported by EasyBuild, see here","title":"Prerequisites"},{"location":"#practical-information","text":"For the sake of this tutorial, you can: use the #tutorial channel in the EasyBuild Slack for asking questions or getting help; use AWS Cloud9 for the hands-on exercises; use the prepared container image through Docker or Singularity; Please see this page for more details.","title":"Practical information"},{"location":"#tutorial-contents","text":"Introduction to EasyBuild Installation (*) Configuration (*) Basic usage (*) Troubleshooting (*) Beyond the basics (*) Hierarchical module naming schemes (*) Adding support for additional software (*) EasyBuild at J\u00fclich Supercomputing Centre EasyBuild at Compute Canada The EasyBuild Community Contributing to EasyBuild (*) Comparison with other tools Getting help (sections indicated with (*) involve hands-on exercises)","title":"Tutorial contents"},{"location":"#additional-resources","text":"website: https://easybuilders.github.io/easybuild documentation: https://easybuild.readthedocs.io GitHub: https://github.com/easybuilders Slack: https://easybuild.slack.com (self-request an invite here ) mailing list: https://lists.ugent.be/wws/subscribe/easybuild","title":"Additional resources"},{"location":"00_practical_information/","text":"Practical information (WIP) \u00b6 Below you can find practical information on the provided resources for this tutorial. Slack \u00b6 There is a dedicated #tutorial channel in the EasyBuild Slack to get in touch with the tutorial organisers, where you can ask questions throughout the tutorial, or ask for help if needed. To connect, you will need to create an account in the EasyBuild Slack first, which you can do via https://easybuild-slack.herokuapp.com/ . Once you have an account, you can join the EasyBuild Slack via https://easybuild.slack.com/ , and then join the #tutorial channel. AWS resources \u00b6 (only available during the tutorial in June 2020) Access to a shell environment on AWS Cloud9 is provided for this tutorial. You should have received an email with connection information if you have registered in time for this tutorial. If you did not register and would still like to use AWS Cloud9 for this tutorial, please contact the tutorial organisers via Slack. Prepared container image \u00b6 For the purpose of this tutorial, we have prepared a Docker container that you can use to follow the hands-on exercises in a controlled environment. This container image also includes a software stack that was installed using EasyBuild, which will come in useful for some of the exercises. The container is available through the easybuilders/tutorial repository on Docker Hub ( https://hub.docker.com/repository/docker/easybuilders/tutorial ), and can be used with both Docker and Singularity. Requirements for using the container images \u00b6 (only relevant if you are not using AWS Cloud9) having Docker or Singularity installed a processor compatible with software built for Intel Haswell (AVX2 instruction set) Using Docker \u00b6 If you want to use the prepared container image via Docker, run the following docker command: docker run -ti --rm easybuilders/tutorial:isc20 Using Singularity \u00b6 (not available in AWS environment) To use the prepared container image via Singularity, run the following singularity command: singularity run --cleanenv --home /tmp/ $USER /fakehome docker://easybuilders/tutorial:isc20 The additional options are required to: --cleanenv : start with clean environment --home /tmp/$USER/fakehome : use (empty) /tmp/$USER/fakehome directory as home directory in container This is mainly to avoid that anything from the host environment or your home directory \"leaks\" into the container, which could interfere with the hands-on exercises.","title":"0. Practical information"},{"location":"00_practical_information/#practical-information-wip","text":"Below you can find practical information on the provided resources for this tutorial.","title":"Practical information (WIP)"},{"location":"00_practical_information/#slack","text":"There is a dedicated #tutorial channel in the EasyBuild Slack to get in touch with the tutorial organisers, where you can ask questions throughout the tutorial, or ask for help if needed. To connect, you will need to create an account in the EasyBuild Slack first, which you can do via https://easybuild-slack.herokuapp.com/ . Once you have an account, you can join the EasyBuild Slack via https://easybuild.slack.com/ , and then join the #tutorial channel.","title":"Slack"},{"location":"00_practical_information/#aws-resources","text":"(only available during the tutorial in June 2020) Access to a shell environment on AWS Cloud9 is provided for this tutorial. You should have received an email with connection information if you have registered in time for this tutorial. If you did not register and would still like to use AWS Cloud9 for this tutorial, please contact the tutorial organisers via Slack.","title":"AWS resources"},{"location":"00_practical_information/#prepared-container-image","text":"For the purpose of this tutorial, we have prepared a Docker container that you can use to follow the hands-on exercises in a controlled environment. This container image also includes a software stack that was installed using EasyBuild, which will come in useful for some of the exercises. The container is available through the easybuilders/tutorial repository on Docker Hub ( https://hub.docker.com/repository/docker/easybuilders/tutorial ), and can be used with both Docker and Singularity.","title":"Prepared container image"},{"location":"00_practical_information/#requirements-for-using-the-container-images","text":"(only relevant if you are not using AWS Cloud9) having Docker or Singularity installed a processor compatible with software built for Intel Haswell (AVX2 instruction set)","title":"Requirements for using the container images"},{"location":"00_practical_information/#using-docker","text":"If you want to use the prepared container image via Docker, run the following docker command: docker run -ti --rm easybuilders/tutorial:isc20","title":"Using Docker"},{"location":"00_practical_information/#using-singularity","text":"(not available in AWS environment) To use the prepared container image via Singularity, run the following singularity command: singularity run --cleanenv --home /tmp/ $USER /fakehome docker://easybuilders/tutorial:isc20 The additional options are required to: --cleanenv : start with clean environment --home /tmp/$USER/fakehome : use (empty) /tmp/$USER/fakehome directory as home directory in container This is mainly to avoid that anything from the host environment or your home directory \"leaks\" into the container, which could interfere with the hands-on exercises.","title":"Using Singularity"},{"location":"01_introduction/","text":"Introduction \u00b6 What is EasyBuild? \u00b6 EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromises on performance. Easybuild is especially tailored towards High Performance Computing (HPC) environments. Elevator pitch \u00b6 EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown out to be a platform for collaboration with HPC sites worldwide. Key features \u00b6 EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. It is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations if required. The installation procedure executed by EasyBuild is thoroughly logged and fully transparent via dry run and tracing . EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers (Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. The project is actively developed by a worldwide community, with stable versions being released every 6-8 weeks since 2012. Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment, consistent testing of incoming contributions, and thorough regression testing before every release. What EasyBuild is not \u00b6 EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package manangers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, Infiniband, GPU drivers, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is *not a magic solution to all your (software installation) problems . You may, and probably will still occasionally, run into compiler errors unless somebody has already taken care of the problem for you. Implementation \u00b6 EasyBuild is implemented in Python , and fully supports both Python 2.7 and 3.5+. Releases are published via PyPI , under the GPLv2 open source license . Development is done through the easybuilders organisation on GitHub , where each of the EasyBuild components is hosted in a separate repository. Terminology \u00b6 Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms. Framework \u00b6 The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.tools , etc.) that collectively form the heart of EasyBuild . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this (see easyblocks ). Easyblocks \u00b6 An easyblock is a Python module that implements a specific software installation procedure . It can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , ... The installation procedure performed by an easyblock can be controlled by defining so-called easyconfig parameters (see easyconfig files ). Easyconfig files \u00b6 Easyconfig files (or easyconfigs for short), are simple text files (written in Python syntax) that specify what EasyBuild should install . They define the different easyconfig parameters that collectively form a complete specification for a particular software installation. Some easyconfig parameters are mandatory , these must be defined in each easyconfig file: name and version , which specify the name and version of the software to install (surprise!); homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains tab); Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock . Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify (drum roll...) the list of (build) dependencies; configopts , buildopts , and installopts , which speficy options for the configuration/build/install commands, resp.; Extensions \u00b6 Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Examples are Python packages , R libraries and Perl modules (can you tell why we had to come up with a different term?). Extensions can be installed in different ways: stand-alone, as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as, well, an extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation); Dependencies \u00b6 A dependency is a common term in the context of software, which we probably don't need to define at length, but here it goes anyway: it refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (to support specific features for example). There are multiple types of dependencies: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software; a runtime dependency (or just dependency for short) is a software package that is required to use (or run ) another software package; a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending (hah!) on how the software is installed exactly; The distinction between link-time and build/runtime dependencies is mostly irrelevant for this tutorial though. Toolchains \u00b6 A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, and additional libraries which provide specific functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components typically are special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Tranforms (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries). Modules \u00b6 Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, etc.). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies for which environment variables the value should be updated, and how (append, prepend, (re)define, undefine, etc.). Environment module files are processed via a modules tool , of which there are several conceptually similar yet slighty different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. EasyBuild heavily relies on environment modules, and hence having a modules tool installed is a strict requirement in order to use EasyBuild . Both Lmod and the Tcl-based Environment Modules tools are supported by EasyBuild, as well as module files in both Tcl and Lua syntax. Module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used. Bringing it all together \u00b6 The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files . EasyBuild ensures that the specified dependencies are installed, and automatically generates a set of (environment) modules that facilitate access to the installed software. Focus points \u00b6 EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made. Performance \u00b6 We strongly prefer building software from source , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of processors on which the software will be used. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour can be changed via the --optarch configuration setting , if desired. Reproducibility \u00b6 In addition to performance, reproducibility of installations is another major focus point. Most software installations done with EasyBuild use a particular toolchain , with which we aim to take control over the build environment and avoid relying on tools & libraries provided by the OS. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions (like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the OS). For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild. Community effort \u00b6 In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems & bugs, to submit ideas for additional features and improvements, and to contribute back when they can, be it by opening pull requests to the EasyBuild framework , easyblocks , easyconfigs repositories, or to the EasyBuild documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening new pull requests & updating existing, testing pull requests, reviewing incoming contributions, ... can all be done straight from the EasyBuild command line. This not only saves time, effort, brain cycles and mouse clicks for contributors, it also makes the review process for maintainers significantly easier, and it leads to better stability & consistency. The EasyBuild community \u00b6 EasyBuild was originally created by the HPC team at Ghent University (Belgium) in 2009, and was developed in-house before it was publicly released in 2012. Since then it has grown out to a community project , which is used and developed by various HPC centres & consortia worldwide, including (but not limited to): Flemish Supercomputer Centre (VSC), Belgium Consortium des \u00c9quipements de Calcul Intensif (C\u00c9CI), Belgium J\u00fclich Supercomputing Centre (JSC), Germany Swiss National Supercomputing Centre (CSCS) Birmingham Environment for Academic Research (BEAR), UK SURFsara, Netherlands Swedish National Infrastructure for Computing (SNIC) Compute Canada Fred Hutchinson Cancer Research Center, US Texas A&M University (TAMU) High Performance Research Computing (HPRC), US National University of Singapore (NUS) University of Melbourne, Australia HPCNow! Today, an experienced team of HPC experts actively maintains the project, by implementing additional features and bug fixes, and processing incoming contributions. The EasyBuild documentation is available at https://easybuild.readthedocs.io . You can interact with the EasyBuild community via the Slack channel (request an invitation here ), or subscribe to the mailing list .","title":"1. Introduction"},{"location":"01_introduction/#introduction","text":"","title":"Introduction"},{"location":"01_introduction/#what-is-easybuild","text":"EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromises on performance. Easybuild is especially tailored towards High Performance Computing (HPC) environments.","title":"What is EasyBuild?"},{"location":"01_introduction/#elevator-pitch","text":"EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown out to be a platform for collaboration with HPC sites worldwide.","title":"Elevator pitch"},{"location":"01_introduction/#key-features","text":"EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. It is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations if required. The installation procedure executed by EasyBuild is thoroughly logged and fully transparent via dry run and tracing . EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers (Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. The project is actively developed by a worldwide community, with stable versions being released every 6-8 weeks since 2012. Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment, consistent testing of incoming contributions, and thorough regression testing before every release.","title":"Key features"},{"location":"01_introduction/#what-easybuild-is-not","text":"EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package manangers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, Infiniband, GPU drivers, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is *not a magic solution to all your (software installation) problems . You may, and probably will still occasionally, run into compiler errors unless somebody has already taken care of the problem for you.","title":"What EasyBuild is not"},{"location":"01_introduction/#implementation","text":"EasyBuild is implemented in Python , and fully supports both Python 2.7 and 3.5+. Releases are published via PyPI , under the GPLv2 open source license . Development is done through the easybuilders organisation on GitHub , where each of the EasyBuild components is hosted in a separate repository.","title":"Implementation"},{"location":"01_introduction/#terminology","text":"Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms.","title":"Terminology"},{"location":"01_introduction/#framework","text":"The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.tools , etc.) that collectively form the heart of EasyBuild . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this (see easyblocks ).","title":"Framework"},{"location":"01_introduction/#easyblocks","text":"An easyblock is a Python module that implements a specific software installation procedure . It can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , ... The installation procedure performed by an easyblock can be controlled by defining so-called easyconfig parameters (see easyconfig files ).","title":"Easyblocks"},{"location":"01_introduction/#easyconfig-files","text":"Easyconfig files (or easyconfigs for short), are simple text files (written in Python syntax) that specify what EasyBuild should install . They define the different easyconfig parameters that collectively form a complete specification for a particular software installation. Some easyconfig parameters are mandatory , these must be defined in each easyconfig file: name and version , which specify the name and version of the software to install (surprise!); homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains tab); Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock . Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify (drum roll...) the list of (build) dependencies; configopts , buildopts , and installopts , which speficy options for the configuration/build/install commands, resp.;","title":"Easyconfig files"},{"location":"01_introduction/#extensions","text":"Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Examples are Python packages , R libraries and Perl modules (can you tell why we had to come up with a different term?). Extensions can be installed in different ways: stand-alone, as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as, well, an extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation);","title":"Extensions"},{"location":"01_introduction/#dependencies","text":"A dependency is a common term in the context of software, which we probably don't need to define at length, but here it goes anyway: it refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (to support specific features for example). There are multiple types of dependencies: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software; a runtime dependency (or just dependency for short) is a software package that is required to use (or run ) another software package; a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending (hah!) on how the software is installed exactly; The distinction between link-time and build/runtime dependencies is mostly irrelevant for this tutorial though.","title":"Dependencies"},{"location":"01_introduction/#toolchains","text":"A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, and additional libraries which provide specific functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components typically are special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Tranforms (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).","title":"Toolchains"},{"location":"01_introduction/#modules","text":"Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, etc.). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies for which environment variables the value should be updated, and how (append, prepend, (re)define, undefine, etc.). Environment module files are processed via a modules tool , of which there are several conceptually similar yet slighty different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. EasyBuild heavily relies on environment modules, and hence having a modules tool installed is a strict requirement in order to use EasyBuild . Both Lmod and the Tcl-based Environment Modules tools are supported by EasyBuild, as well as module files in both Tcl and Lua syntax. Module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.","title":"Modules"},{"location":"01_introduction/#bringing-it-all-together","text":"The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files . EasyBuild ensures that the specified dependencies are installed, and automatically generates a set of (environment) modules that facilitate access to the installed software.","title":"Bringing it all together"},{"location":"01_introduction/#focus-points","text":"EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made.","title":"Focus points"},{"location":"01_introduction/#performance","text":"We strongly prefer building software from source , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of processors on which the software will be used. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour can be changed via the --optarch configuration setting , if desired.","title":"Performance"},{"location":"01_introduction/#reproducibility","text":"In addition to performance, reproducibility of installations is another major focus point. Most software installations done with EasyBuild use a particular toolchain , with which we aim to take control over the build environment and avoid relying on tools & libraries provided by the OS. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions (like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the OS). For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.","title":"Reproducibility"},{"location":"01_introduction/#community-effort","text":"In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems & bugs, to submit ideas for additional features and improvements, and to contribute back when they can, be it by opening pull requests to the EasyBuild framework , easyblocks , easyconfigs repositories, or to the EasyBuild documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening new pull requests & updating existing, testing pull requests, reviewing incoming contributions, ... can all be done straight from the EasyBuild command line. This not only saves time, effort, brain cycles and mouse clicks for contributors, it also makes the review process for maintainers significantly easier, and it leads to better stability & consistency.","title":"Community effort"},{"location":"01_introduction/#the-easybuild-community","text":"EasyBuild was originally created by the HPC team at Ghent University (Belgium) in 2009, and was developed in-house before it was publicly released in 2012. Since then it has grown out to a community project , which is used and developed by various HPC centres & consortia worldwide, including (but not limited to): Flemish Supercomputer Centre (VSC), Belgium Consortium des \u00c9quipements de Calcul Intensif (C\u00c9CI), Belgium J\u00fclich Supercomputing Centre (JSC), Germany Swiss National Supercomputing Centre (CSCS) Birmingham Environment for Academic Research (BEAR), UK SURFsara, Netherlands Swedish National Infrastructure for Computing (SNIC) Compute Canada Fred Hutchinson Cancer Research Center, US Texas A&M University (TAMU) High Performance Research Computing (HPRC), US National University of Singapore (NUS) University of Melbourne, Australia HPCNow! Today, an experienced team of HPC experts actively maintains the project, by implementing additional features and bug fixes, and processing incoming contributions. The EasyBuild documentation is available at https://easybuild.readthedocs.io . You can interact with the EasyBuild community via the Slack channel (request an invitation here ), or subscribe to the mailing list .","title":"The EasyBuild community"},{"location":"01_introduction/slides/","text":"Introducing EasyBuild (slide 1) \u00b6 foo bar Introducing EasyBuild (slide 2) \u00b6 blah blah","title":"Slides"},{"location":"01_introduction/slides/#introducing-easybuild-slide-1","text":"foo bar","title":"Introducing EasyBuild (slide 1)"},{"location":"01_introduction/slides/#introducing-easybuild-slide-2","text":"blah blah","title":"Introducing EasyBuild (slide 2)"},{"location":"02_installation/","text":"Installation \u00b6 Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline the different ways of doing so, and the things you should pay attention to. By the end of it, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Executive summary \u00b6 requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended) installation methods: pip install easybuild bootstrapping EasyBuild verify EasyBuild installation using eb --version , eb --help Requirements \u00b6 Linux \u00b6 The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like contributing back to the project. Python \u00b6 EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution is sufficient. Some additional Python packages can be leveraged for specific features, more on that later. Environment modules tool \u00b6 An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also compatible with EasyBuild however. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information. EasyBuild as a Python package \u00b6 EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of standard Python installation tools (did you catch the irony in that last bit?). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve! Python 2 or Python 3? \u00b6 It does not matter whether you install EasyBuild on top of Python 2 or Python 3, in no way does this affect the functionality. Since Python 2 is end-of-life , we recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed. For more information, see the EasyBuild documentation . Installing EasyBuild \u00b6 We present two methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty! Method 1: Using pip (recommended) \u00b6 Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild. Running pip install \u00b6 Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). Updating your environment \u00b6 If you used the --user or --prefix option in the pip install command, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory ( .bashrc for example). $PATH Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). $PYTHONPATH If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 2.7, make sure you are using ' python2.7 ' in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH Method 2: Bootstrapping EasyBuild \u00b6 Note This section covers an alternative installation method. If you already have EasyBuild installed, you can skip ahead to the next section . If pip is not available or if the installation with pip is not working out for some reason, you can resort to using the bootstrapping procedure for installing EasyBuild . In essence, the bootstrap script installs EasyBuild into a temporary location and then uses this temporary EasyBuild installation to install EasyBuild into the specified directory and provide a module for it. Step 1: Downloading the bootstrap script \u00b6 First, download the latest version of the EasyBuild bootstrap script from GitHub. An easy way to do this is by running this curl command: curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py Step 2: Running the bootstrap script \u00b6 To install EasyBuild using the bootstrap script simply run it using the python command and specify the installation prefix as an argument: python bootstrap_eb.py _PREFIX_ Replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). Step 3: Loading the EasyBuild module \u00b6 Once the bootstrap procedure completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' in the same way as you did when running the bootstrap script. Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note No output will be generated by either of these module commands, that's completely normal. Verifying the installation \u00b6 Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation: Checking the version \u00b6 To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version . Consulting the help output \u00b6 You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help Showing the default EasyBuild configuration \u00b6 To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial. Updating EasyBuild \u00b6 Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. Warning Make sure you have EasyBuild installed before you proceed with the rest of the tutorial!","title":"2. Installation"},{"location":"02_installation/#installation","text":"Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline the different ways of doing so, and the things you should pay attention to. By the end of it, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial.","title":"Installation"},{"location":"02_installation/#executive-summary","text":"requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended) installation methods: pip install easybuild bootstrapping EasyBuild verify EasyBuild installation using eb --version , eb --help","title":"Executive summary"},{"location":"02_installation/#requirements","text":"","title":"Requirements"},{"location":"02_installation/#linux","text":"The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like contributing back to the project.","title":"Linux"},{"location":"02_installation/#python","text":"EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution is sufficient. Some additional Python packages can be leveraged for specific features, more on that later.","title":"Python"},{"location":"02_installation/#environment-modules-tool","text":"An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also compatible with EasyBuild however. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.","title":"Environment modules tool"},{"location":"02_installation/#easybuild-as-a-python-package","text":"EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of standard Python installation tools (did you catch the irony in that last bit?). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!","title":"EasyBuild as a Python package"},{"location":"02_installation/#python-2-or-python-3","text":"It does not matter whether you install EasyBuild on top of Python 2 or Python 3, in no way does this affect the functionality. Since Python 2 is end-of-life , we recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed. For more information, see the EasyBuild documentation .","title":"Python 2 or Python 3?"},{"location":"02_installation/#installing-easybuild","text":"We present two methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty!","title":"Installing EasyBuild"},{"location":"02_installation/#method-1-using-pip-recommended","text":"Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild.","title":"Method 1: Using pip (recommended)"},{"location":"02_installation/#running-pip-install","text":"Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Running pip install"},{"location":"02_installation/#updating-your-environment","text":"If you used the --user or --prefix option in the pip install command, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory ( .bashrc for example). $PATH Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). $PYTHONPATH If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 2.7, make sure you are using ' python2.7 ' in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH","title":"Updating your environment"},{"location":"02_installation/#method-2-bootstrapping-easybuild","text":"Note This section covers an alternative installation method. If you already have EasyBuild installed, you can skip ahead to the next section . If pip is not available or if the installation with pip is not working out for some reason, you can resort to using the bootstrapping procedure for installing EasyBuild . In essence, the bootstrap script installs EasyBuild into a temporary location and then uses this temporary EasyBuild installation to install EasyBuild into the specified directory and provide a module for it.","title":"Method 2: Bootstrapping EasyBuild"},{"location":"02_installation/#step-1-downloading-the-bootstrap-script","text":"First, download the latest version of the EasyBuild bootstrap script from GitHub. An easy way to do this is by running this curl command: curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py","title":"Step 1: Downloading the bootstrap script"},{"location":"02_installation/#step-2-running-the-bootstrap-script","text":"To install EasyBuild using the bootstrap script simply run it using the python command and specify the installation prefix as an argument: python bootstrap_eb.py _PREFIX_ Replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Step 2: Running the bootstrap script"},{"location":"02_installation/#step-3-loading-the-easybuild-module","text":"Once the bootstrap procedure completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' in the same way as you did when running the bootstrap script. Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note No output will be generated by either of these module commands, that's completely normal.","title":"Step 3: Loading the EasyBuild module"},{"location":"02_installation/#verifying-the-installation","text":"Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:","title":"Verifying the installation"},{"location":"02_installation/#checking-the-version","text":"To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version .","title":"Checking the version"},{"location":"02_installation/#consulting-the-help-output","text":"You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help","title":"Consulting the help output"},{"location":"02_installation/#showing-the-default-easybuild-configuration","text":"To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial.","title":"Showing the default EasyBuild configuration"},{"location":"02_installation/#updating-easybuild","text":"Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. Warning Make sure you have EasyBuild installed before you proceed with the rest of the tutorial!","title":"Updating EasyBuild"},{"location":"02_installation/slides/","text":"Installation \u00b6 To install EasyBuild: pip install --prefix $HOME /tools easybuild export PATH = $HOME /tools/bin: $PATH export PYTHONPATH = $HOME /tools/lib/python2.7/site-packages: $PYTHONPATH","title":"Slides"},{"location":"02_installation/slides/#installation","text":"To install EasyBuild: pip install --prefix $HOME /tools easybuild export PATH = $HOME /tools/bin: $PATH export PYTHONPATH = $HOME /tools/lib/python2.7/site-packages: $PYTHONPATH","title":"Installation"},{"location":"03_configuration/","text":"Configuration \u00b6 After installing EasyBuild you should configure EasyBuild to your preferences . Although EasyBuild should work fine out-of-the-box assuming that you are using Lmod as modules tool (if not, see here ), you will probably not be happy with the default configuration. Note Configuring EasyBuild is also covered in detail in the EasyBuild documentation, see here . Available configuration settings \u00b6 One of the central policies in the EasyBuid project is to avoid hardcoded settings in the codebase. While this significantly increases flexibility to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, over 230 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings, which we feel are the most prominent and important ones. Note We will usually refer to configuration settings using the name as it appears in the output of eb --help , which may includes dashes ( - ). The leading ' -- ' is omitted for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 differeny ways, see below for more details. Overall prefix \u00b6 (default: HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting. Install path \u00b6 (default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster, such that the installation can be performed on one node while being accessible on the whole cluster. Of course, software can also be installed on a local filesystem, in particular when testing and evaluating installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory and the default software and modules/all subdirectories are used. Build path \u00b6 (default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is reattempted. Running out of disk space in the location where build directories are created will result in failing installations. It is recommended to use a directory on a local filesystem for buildpath , or an in-memory filesystem like /dev/shm (if you have a significant amount of working memory available on your system). In addition, try to ensure you use a path that does not overlap with other users on the same system. So set buildpath to /tmp/$USER or /dev/shm/$USER , for example. Source path \u00b6 (default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, it will first check if it is already available. The locations considered by EasyBuild when checking for available source files as well as the location to stored downloaded source files can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories as considered. For example, for a software packagamed ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , etc. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files. It will keep them organized by software name through subdirectories. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Any additional paths can be read-only for the account running EasyBuild. Easyconfigs archive \u00b6 (default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported. More information is available in the EasyBuild documentation . For the sake of this tutorial we recommend sticking to a regular directory, and sticking to the default location as specified by the prefix configuration setting. Modules tool & module syntax \u00b6 (default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod. To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool, see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod. We recommend using EasyBuild with Lmod as modules tool and Lua as module syntax. Robot search path \u00b6 (default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between both is that robot also makes EasyBuild resolve dependencies alongside specifying a list of paths to consider when searching for easyconfig files, while defining robot-paths does not have this side effect. In addition, you can use the --robot command line option without specifying any paths to it to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered. There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation . Module naming scheme \u00b6 (default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes ). The default EasyBuildMNS module naming scheme rougly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional labels (which corresponds to value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Note Using a different module naming scheme is largely out of scope for this tutorial, except when covering hierarchical module naming schemes . Configuration levels \u00b6 Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, no exceptions! Configuration level hierarchy \u00b6 There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always win, regardless of whether the corresponding configuration setting was already defined some other way (configuration file or environment variable). For example, let us consider a fictional configuration setting named -magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ). is not defined and if the ---magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting. Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead. Configuration files \u00b6 Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing. EasyBuild configuration files vs easyconfig files \u00b6 EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. These are two entirely different concepts however! EasyBuild configuration files are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. Hopefully this helps to avoid the confusion... $EASYBUILD_* environment variables \u00b6 A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ). eb command line options \u00b6 Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use a command line option. There are various configuration settings for which it only really makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ); although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would not be very useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb Inspecting the current configuration ( --show-config ) \u00b6 Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of how EasyBuild is configured exactly. Therefore, the --show-config command line option is provided to easily inspect the currently active EasyBuild configuration. The output includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , etc.). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produces by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user : # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ) and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Now let us do some basic configuring and inspect the resulting output of --show-config : $ export EASYBUILD_PREFIX = $HOME /easybuild $ export EASYBUILD_BUILDPATH = /dev/shm $ eb --installpath = /tmp/ $USER --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /dev/shm/example containerpath ( E ) = /home/example/easybuild/containers installpath ( C ) = /tmp/example packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources The output indicates that the installpath setting was specified through a command line option (indicated with ' (C) '), that the robot-paths setting still has the default values, and that all other configuration settings were specified via an environment variable (some of which indirectly through the prefix value). Warning Make sure you have EasyBuild properly configured before you proceed with the rest of the tutorial!","title":"3. Configuration"},{"location":"03_configuration/#configuration","text":"After installing EasyBuild you should configure EasyBuild to your preferences . Although EasyBuild should work fine out-of-the-box assuming that you are using Lmod as modules tool (if not, see here ), you will probably not be happy with the default configuration. Note Configuring EasyBuild is also covered in detail in the EasyBuild documentation, see here .","title":"Configuration"},{"location":"03_configuration/#available-configuration-settings","text":"One of the central policies in the EasyBuid project is to avoid hardcoded settings in the codebase. While this significantly increases flexibility to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, over 230 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings, which we feel are the most prominent and important ones. Note We will usually refer to configuration settings using the name as it appears in the output of eb --help , which may includes dashes ( - ). The leading ' -- ' is omitted for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 differeny ways, see below for more details.","title":"Available configuration settings"},{"location":"03_configuration/#overall-prefix","text":"(default: HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting.","title":"Overall prefix"},{"location":"03_configuration/#install-path","text":"(default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster, such that the installation can be performed on one node while being accessible on the whole cluster. Of course, software can also be installed on a local filesystem, in particular when testing and evaluating installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory and the default software and modules/all subdirectories are used.","title":"Install path"},{"location":"03_configuration/#build-path","text":"(default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is reattempted. Running out of disk space in the location where build directories are created will result in failing installations. It is recommended to use a directory on a local filesystem for buildpath , or an in-memory filesystem like /dev/shm (if you have a significant amount of working memory available on your system). In addition, try to ensure you use a path that does not overlap with other users on the same system. So set buildpath to /tmp/$USER or /dev/shm/$USER , for example.","title":"Build path"},{"location":"03_configuration/#source-path","text":"(default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, it will first check if it is already available. The locations considered by EasyBuild when checking for available source files as well as the location to stored downloaded source files can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories as considered. For example, for a software packagamed ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , etc. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files. It will keep them organized by software name through subdirectories. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Any additional paths can be read-only for the account running EasyBuild.","title":"Source path"},{"location":"03_configuration/#easyconfigs-archive","text":"(default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported. More information is available in the EasyBuild documentation . For the sake of this tutorial we recommend sticking to a regular directory, and sticking to the default location as specified by the prefix configuration setting.","title":"Easyconfigs archive"},{"location":"03_configuration/#modules-tool-module-syntax","text":"(default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod. To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool, see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod. We recommend using EasyBuild with Lmod as modules tool and Lua as module syntax.","title":"Modules tool &amp; module syntax"},{"location":"03_configuration/#robot-search-path","text":"(default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between both is that robot also makes EasyBuild resolve dependencies alongside specifying a list of paths to consider when searching for easyconfig files, while defining robot-paths does not have this side effect. In addition, you can use the --robot command line option without specifying any paths to it to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered. There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation .","title":"Robot search path"},{"location":"03_configuration/#module-naming-scheme","text":"(default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes ). The default EasyBuildMNS module naming scheme rougly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional labels (which corresponds to value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Note Using a different module naming scheme is largely out of scope for this tutorial, except when covering hierarchical module naming schemes .","title":"Module naming scheme"},{"location":"03_configuration/#configuration-levels","text":"Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, no exceptions!","title":"Configuration levels"},{"location":"03_configuration/#configuration-level-hierarchy","text":"There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always win, regardless of whether the corresponding configuration setting was already defined some other way (configuration file or environment variable). For example, let us consider a fictional configuration setting named -magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ). is not defined and if the ---magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting. Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead.","title":"Configuration level hierarchy"},{"location":"03_configuration/#configuration-files","text":"Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.","title":"Configuration files"},{"location":"03_configuration/#easybuild-configuration-files-vs-easyconfig-files","text":"EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. These are two entirely different concepts however! EasyBuild configuration files are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. Hopefully this helps to avoid the confusion...","title":"EasyBuild configuration files vs easyconfig files"},{"location":"03_configuration/#easybuild_-environment-variables","text":"A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ).","title":"$EASYBUILD_* environment variables"},{"location":"03_configuration/#eb-command-line-options","text":"Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use a command line option. There are various configuration settings for which it only really makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ); although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would not be very useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb","title":"eb command line options"},{"location":"03_configuration/#inspecting-the-current-configuration-show-config","text":"Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of how EasyBuild is configured exactly. Therefore, the --show-config command line option is provided to easily inspect the currently active EasyBuild configuration. The output includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , etc.). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produces by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user : # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ) and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Now let us do some basic configuring and inspect the resulting output of --show-config : $ export EASYBUILD_PREFIX = $HOME /easybuild $ export EASYBUILD_BUILDPATH = /dev/shm $ eb --installpath = /tmp/ $USER --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /dev/shm/example containerpath ( E ) = /home/example/easybuild/containers installpath ( C ) = /tmp/example packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources The output indicates that the installpath setting was specified through a command line option (indicated with ' (C) '), that the robot-paths setting still has the default values, and that all other configuration settings were specified via an environment variable (some of which indirectly through the prefix value). Warning Make sure you have EasyBuild properly configured before you proceed with the rest of the tutorial!","title":"Inspecting the current configuration (--show-config)"},{"location":"03_configuration/slides/","text":"Configuration \u00b6 (coming soon)","title":"Slides"},{"location":"03_configuration/slides/#configuration","text":"(coming soon)","title":"Configuration"},{"location":"04_basic_usage/","text":"Basic usage \u00b6 Workflow \u00b6 Searching for easyconfigs \u00b6 -S , --search Checking dependencies \u00b6 -D , -M Performing a dry run \u00b6 -x Installing software \u00b6 Enabling dependency resolution \u00b6 Trace output \u00b6 --trace Using installed software \u00b6 Stacking software \u00b6 Hands-on exercises \u00b6 Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for TensorFlow 2.2.0. (click to show solution) eb --search TensorFlow-2.2.0 Exercise 4.2 - Checking dependencies Check which dependencies are missing to install PETSc 3.12.4 with the foss/2020a toolchain. (click to show solution) eb --search 'PETSc-3.12.4.*foss-2020a' eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing Exercise 4.3 - Performing a dry run Inspect the installation procedure for GSL-2.6-GCC-9.3.0.eb by performing a dry run. Which binaries will EasyBuild check for to sanity check the installation? (click to show solution) eb -x GSL-2.6-GCC-9.3.0.eb Binaries: gsl-config , gsl-histogram , gsl-randist . Exercise 4.4 - Installing software Install the h5py Python package and all missing dependencies for Python 3.8.2, into /tmp/$USER/easybuild and leveraging already install software from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) eb --search 'h5py.*Python-3.8.2' module use /easybuild/modules/all eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --missing eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --robot --installpath /tmp/ $USER /easybuild Exercise 4.5 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"mytestfile.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) module use /tmp/ $USER /easybuild/modules/all module avail h5py module load h5py/2.10.0-foss-2020a-Python-3.8.2 python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' h5stat empty.hdf5","title":"4. Basic usage"},{"location":"04_basic_usage/#basic-usage","text":"","title":"Basic usage"},{"location":"04_basic_usage/#workflow","text":"","title":"Workflow"},{"location":"04_basic_usage/#searching-for-easyconfigs","text":"-S , --search","title":"Searching for easyconfigs"},{"location":"04_basic_usage/#checking-dependencies","text":"-D , -M","title":"Checking dependencies"},{"location":"04_basic_usage/#performing-a-dry-run","text":"-x","title":"Performing a dry run"},{"location":"04_basic_usage/#installing-software","text":"","title":"Installing software"},{"location":"04_basic_usage/#enabling-dependency-resolution","text":"","title":"Enabling dependency resolution"},{"location":"04_basic_usage/#trace-output","text":"--trace","title":"Trace output"},{"location":"04_basic_usage/#using-installed-software","text":"","title":"Using installed software"},{"location":"04_basic_usage/#stacking-software","text":"","title":"Stacking software"},{"location":"04_basic_usage/#hands-on-exercises","text":"Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for TensorFlow 2.2.0. (click to show solution) eb --search TensorFlow-2.2.0 Exercise 4.2 - Checking dependencies Check which dependencies are missing to install PETSc 3.12.4 with the foss/2020a toolchain. (click to show solution) eb --search 'PETSc-3.12.4.*foss-2020a' eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing Exercise 4.3 - Performing a dry run Inspect the installation procedure for GSL-2.6-GCC-9.3.0.eb by performing a dry run. Which binaries will EasyBuild check for to sanity check the installation? (click to show solution) eb -x GSL-2.6-GCC-9.3.0.eb Binaries: gsl-config , gsl-histogram , gsl-randist . Exercise 4.4 - Installing software Install the h5py Python package and all missing dependencies for Python 3.8.2, into /tmp/$USER/easybuild and leveraging already install software from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) eb --search 'h5py.*Python-3.8.2' module use /easybuild/modules/all eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --missing eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --robot --installpath /tmp/ $USER /easybuild Exercise 4.5 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"mytestfile.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) module use /tmp/ $USER /easybuild/modules/all module avail h5py module load h5py/2.10.0-foss-2020a-Python-3.8.2 python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' h5stat empty.hdf5","title":"Hands-on exercises"},{"location":"04_basic_usage/slides/","text":"Basic usage \u00b6 Use the eb command line, Luke.","title":"Slides"},{"location":"04_basic_usage/slides/#basic-usage","text":"Use the eb command line, Luke.","title":"Basic usage"},{"location":"05_troubleshooting/","text":"Troubleshooting \u00b6 Inspecting the build directory \u00b6 Navigating log files \u00b6 Common patterns for error messages \u00b6","title":"5. Troubleshooting"},{"location":"05_troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"05_troubleshooting/#inspecting-the-build-directory","text":"","title":"Inspecting the build directory"},{"location":"05_troubleshooting/#navigating-log-files","text":"","title":"Navigating log files"},{"location":"05_troubleshooting/#common-patterns-for-error-messages","text":"","title":"Common patterns for error messages"},{"location":"05_troubleshooting/slides/","text":"Troubleshooting \u00b6 In trouble, huh?","title":"Slides"},{"location":"05_troubleshooting/slides/#troubleshooting","text":"In trouble, huh?","title":"Troubleshooting"},{"location":"06_beyond_the_basics/","text":"Beyond the basics \u00b6 Adding support for additional software \u00b6 Using a custom module naming scheme \u00b6 Multi-architecture software stacks \u00b6","title":"6. Beyond the basics"},{"location":"06_beyond_the_basics/#beyond-the-basics","text":"","title":"Beyond the basics"},{"location":"06_beyond_the_basics/#adding-support-for-additional-software","text":"","title":"Adding support for additional software"},{"location":"06_beyond_the_basics/#using-a-custom-module-naming-scheme","text":"","title":"Using a custom module naming scheme"},{"location":"06_beyond_the_basics/#multi-architecture-software-stacks","text":"","title":"Multi-architecture software stacks"},{"location":"06_beyond_the_basics/slides/","text":"Beyond the basics: foo \u00b6 Beyond the basics: bar \u00b6 Beyond the basics: baz \u00b6","title":"Slides"},{"location":"06_beyond_the_basics/slides/#beyond-the-basics-foo","text":"","title":"Beyond the basics: foo"},{"location":"06_beyond_the_basics/slides/#beyond-the-basics-bar","text":"","title":"Beyond the basics: bar"},{"location":"06_beyond_the_basics/slides/#beyond-the-basics-baz","text":"","title":"Beyond the basics: baz"},{"location":"07_hmns/","text":"Hierarchical module naming schemes \u00b6 Flat vs hierarchical \u00b6 Procs & cons \u00b6","title":"7. Hierarchical module naming schemes"},{"location":"07_hmns/#hierarchical-module-naming-schemes","text":"","title":"Hierarchical module naming schemes"},{"location":"07_hmns/#flat-vs-hierarchical","text":"","title":"Flat vs hierarchical"},{"location":"07_hmns/#procs-cons","text":"","title":"Procs &amp; cons"},{"location":"07_hmns/slides/","text":"Hierarchical module naming schemes \u00b6 Or HMNS for short.","title":"Slides"},{"location":"07_hmns/slides/#hierarchical-module-naming-schemes","text":"Or HMNS for short.","title":"Hierarchical module naming schemes"},{"location":"08_adding_support_software/","text":"Adding support for additional software \u00b6 Easyconfigs vs easyblocks \u00b6 Writing easyconfig files \u00b6 1 2 3 4 name = 'example' version = '1.2.3' toolchain = { 'name' : 'foss' , 'version' : '2019b' } graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] Mandatory parameters \u00b6 Software name & version \u00b6 Homepage and description \u00b6 Toolchain \u00b6 Commonly used parameters \u00b6 Easyblock \u00b6 generic vs software-specific common generic easyblocks Sources \u00b6 Dependencies \u00b6 Command options \u00b6 Sanity check \u00b6 Module class \u00b6 Custom parameters \u00b6 eb -a --easyblock Implementing easyblocks \u00b6 (out of scope) Hands-on exercises \u00b6 Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for TensorFlow 2.2.0. (click to show solution) eb --search TensorFlow-2.2.0","title":"8. Adding support for additional software"},{"location":"08_adding_support_software/#adding-support-for-additional-software","text":"","title":"Adding support for additional software"},{"location":"08_adding_support_software/#easyconfigs-vs-easyblocks","text":"","title":"Easyconfigs vs easyblocks"},{"location":"08_adding_support_software/#writing-easyconfig-files","text":"1 2 3 4 name = 'example' version = '1.2.3' toolchain = { 'name' : 'foss' , 'version' : '2019b' } graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2]","title":"Writing easyconfig files"},{"location":"08_adding_support_software/#mandatory-parameters","text":"","title":"Mandatory parameters"},{"location":"08_adding_support_software/#software-name-version","text":"","title":"Software name &amp; version"},{"location":"08_adding_support_software/#homepage-and-description","text":"","title":"Homepage and description"},{"location":"08_adding_support_software/#toolchain","text":"","title":"Toolchain"},{"location":"08_adding_support_software/#commonly-used-parameters","text":"","title":"Commonly used parameters"},{"location":"08_adding_support_software/#easyblock","text":"generic vs software-specific common generic easyblocks","title":"Easyblock"},{"location":"08_adding_support_software/#sources","text":"","title":"Sources"},{"location":"08_adding_support_software/#dependencies","text":"","title":"Dependencies"},{"location":"08_adding_support_software/#command-options","text":"","title":"Command options"},{"location":"08_adding_support_software/#sanity-check","text":"","title":"Sanity check"},{"location":"08_adding_support_software/#module-class","text":"","title":"Module class"},{"location":"08_adding_support_software/#custom-parameters","text":"eb -a --easyblock","title":"Custom parameters"},{"location":"08_adding_support_software/#implementing-easyblocks","text":"(out of scope)","title":"Implementing easyblocks"},{"location":"08_adding_support_software/#hands-on-exercises","text":"Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for TensorFlow 2.2.0. (click to show solution) eb --search TensorFlow-2.2.0","title":"Hands-on exercises"},{"location":"08_adding_support_software/slides/","text":"Adding support for additional software \u00b6 A.k.a. writing your own easyconfig files.","title":"Slides"},{"location":"08_adding_support_software/slides/#adding-support-for-additional-software","text":"A.k.a. writing your own easyconfig files.","title":"Adding support for additional software"},{"location":"09_jsc/","text":"","title":"9. EasyBuild at J\u00fclich Supercomputing Centre"},{"location":"09_jsc/slides/","text":"EasyBuild at J\u00fclich Supercomputing Centre (JSC) \u00b6 TODO: Alan O'Cais","title":"Slides"},{"location":"09_jsc/slides/#easybuild-at-julich-supercomputing-centre-jsc","text":"TODO: Alan O'Cais","title":"EasyBuild at J\u00fclich Supercomputing Centre (JSC)"},{"location":"10_computecanada/","text":"","title":"10. EasyBuild at Compute Canada"},{"location":"10_computecanada/slides/","text":"EasyBuild at Compute Canada \u00b6 TODO: Maxime?","title":"Slides"},{"location":"10_computecanada/slides/#easybuild-at-compute-canada","text":"TODO: Maxime?","title":"EasyBuild at Compute Canada"},{"location":"11_community/","text":"","title":"11. The EasyBuild Community"},{"location":"11_community/slides/","text":"The EasyBuild community \u00b6 Divide & conquer.","title":"Slides"},{"location":"11_community/slides/#the-easybuild-community","text":"Divide & conquer.","title":"The EasyBuild community"},{"location":"12_contributing/","text":"","title":"12. Contributing to EasyBuild"},{"location":"12_contributing/slides/","text":"Contributing to EasyBuild \u00b6 You know you want to.","title":"Slides"},{"location":"12_contributing/slides/#contributing-to-easybuild","text":"You know you want to.","title":"Contributing to EasyBuild"},{"location":"13_comparison_other_tools/","text":"","title":"13. Comparison with other tools"},{"location":"13_comparison_other_tools/slides/","text":"Comparison with other tools: Spark \u00b6 Or Slack?","title":"Slides"},{"location":"13_comparison_other_tools/slides/#comparison-with-other-tools-spark","text":"Or Slack?","title":"Comparison with other tools: Spark"},{"location":"14_getting_help/","text":"","title":"14. Getting help"},{"location":"14_getting_help/slides/","text":"Getting help \u00b6 mailing list GitHub issues Slack","title":"Slides"},{"location":"14_getting_help/slides/#getting-help","text":"mailing list GitHub issues Slack","title":"Getting help"}]}