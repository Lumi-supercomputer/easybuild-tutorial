{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Warning (Apr 19th 2020) This is very much a work in progress! Many pages are still empty, that will hopefully change soon... Welcome to the official EasyBuild tutorial! \u00b6 Scope \u00b6 This is an introductory tutorial to EasyBuild , a command line tool for installing (scientific) software on High Performance Computing (HPC) systems. It aims to explain the core concepts of EasyBuild, get you started with using it, make you familiar with some of the features it provides, and show how it is used by large HPC sites to maintain their central software stacks. Through hands-on exercises and demos, you will learn how EasyBuild can help you to get scientific software installed in an efficient way. Intended audience \u00b6 This tutorial is primarily intended for people new to EasyBuild, but even if you're already familiar with the project it could be interesting to step through it. Our main target audience includes: HPC system administrators HPC user support team members scientific researchers using HPC systems Prerequisites \u00b6 We expect you to be (a little bit) familiar with: using a Linux command line interface the (absolute) basics of compiling software from source Required software: OS: GNU/Linux (any distribution) Python 2.7 or 3.5+ an environment modules tool (see the module command) we recommend Lmod , a modern environment modules tool implemented in Lua for more information on the environment modules tools supported by EasyBuild, see here Practical information \u00b6 For the sake of this tutorial, you can: use the #tutorial channel in the EasyBuild Slack for asking questions or getting help; use AWS Cloud9 for the hands-on exercises; use the prepared container image through Docker or Singularity; Please see this page for more details. Tutorial contents \u00b6 Introduction to EasyBuild Installation (*) Configuration (*) Basic usage (*) Troubleshooting (*) Beyond the basics (*) Hierarchical module naming schemes (*) Adding support for additional software (*) EasyBuild at J\u00fclich Supercomputing Centre EasyBuild at Compute Canada The EasyBuild Community Contributing to EasyBuild (*) Comparison with other tools Getting help (sections indicated with (*) involve hands-on exercises) Contributors \u00b6 Maxime Boissonneault ( @mboisson , Compute Canada ) Kenneth Hoste ( @boegel , HPC-UGent, Belgium ) Michael Kelsey ( @kelseymh , Texas A&M University, US ) Christian Kniep ( @ChristianKniep , AWS ) Terje Kvernes ( @terjekv , University of Oslo, Norway ) Alan O'Cais ( @ocaisa , J\u00fclich Supercomputing Centre, Germany ) \u00c5ke Sandgren ( @akesandgren , Ume\u00e5 University, Sweden ) Additional resources \u00b6 website: https://easybuilders.github.io/easybuild documentation: https://easybuild.readthedocs.io GitHub: https://github.com/easybuilders Slack: https://easybuild.slack.com (self-request an invite here ) mailing list: https://lists.ugent.be/wws/subscribe/easybuild","title":""},{"location":"#welcome-to-the-official-easybuild-tutorial","text":"","title":"Welcome to the official EasyBuild tutorial!"},{"location":"#scope","text":"This is an introductory tutorial to EasyBuild , a command line tool for installing (scientific) software on High Performance Computing (HPC) systems. It aims to explain the core concepts of EasyBuild, get you started with using it, make you familiar with some of the features it provides, and show how it is used by large HPC sites to maintain their central software stacks. Through hands-on exercises and demos, you will learn how EasyBuild can help you to get scientific software installed in an efficient way.","title":"Scope"},{"location":"#intended-audience","text":"This tutorial is primarily intended for people new to EasyBuild, but even if you're already familiar with the project it could be interesting to step through it. Our main target audience includes: HPC system administrators HPC user support team members scientific researchers using HPC systems","title":"Intended audience"},{"location":"#prerequisites","text":"We expect you to be (a little bit) familiar with: using a Linux command line interface the (absolute) basics of compiling software from source Required software: OS: GNU/Linux (any distribution) Python 2.7 or 3.5+ an environment modules tool (see the module command) we recommend Lmod , a modern environment modules tool implemented in Lua for more information on the environment modules tools supported by EasyBuild, see here","title":"Prerequisites"},{"location":"#practical-information","text":"For the sake of this tutorial, you can: use the #tutorial channel in the EasyBuild Slack for asking questions or getting help; use AWS Cloud9 for the hands-on exercises; use the prepared container image through Docker or Singularity; Please see this page for more details.","title":"Practical information"},{"location":"#tutorial-contents","text":"Introduction to EasyBuild Installation (*) Configuration (*) Basic usage (*) Troubleshooting (*) Beyond the basics (*) Hierarchical module naming schemes (*) Adding support for additional software (*) EasyBuild at J\u00fclich Supercomputing Centre EasyBuild at Compute Canada The EasyBuild Community Contributing to EasyBuild (*) Comparison with other tools Getting help (sections indicated with (*) involve hands-on exercises)","title":"Tutorial contents"},{"location":"#contributors","text":"Maxime Boissonneault ( @mboisson , Compute Canada ) Kenneth Hoste ( @boegel , HPC-UGent, Belgium ) Michael Kelsey ( @kelseymh , Texas A&M University, US ) Christian Kniep ( @ChristianKniep , AWS ) Terje Kvernes ( @terjekv , University of Oslo, Norway ) Alan O'Cais ( @ocaisa , J\u00fclich Supercomputing Centre, Germany ) \u00c5ke Sandgren ( @akesandgren , Ume\u00e5 University, Sweden )","title":"Contributors"},{"location":"#additional-resources","text":"website: https://easybuilders.github.io/easybuild documentation: https://easybuild.readthedocs.io GitHub: https://github.com/easybuilders Slack: https://easybuild.slack.com (self-request an invite here ) mailing list: https://lists.ugent.be/wws/subscribe/easybuild","title":"Additional resources"},{"location":"adding_support_software/","text":"Adding support for additional software \u00b6 Easyconfigs vs easyblocks \u00b6 Writing easyconfig files \u00b6 1 2 3 4 name = 'example' version = '1.2.3' toolchain = { 'name' : 'foss' , 'version' : '2019b' } graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] Mandatory parameters \u00b6 Software name & version \u00b6 Homepage and description \u00b6 Toolchain \u00b6 Commonly used parameters \u00b6 Easyblock \u00b6 generic vs software-specific common generic easyblocks Sources \u00b6 Dependencies \u00b6 Command options \u00b6 Sanity check \u00b6 Module class \u00b6 Custom parameters \u00b6 eb -a --easyblock Generating tweaked easyconfigs \u00b6 --try-* Copying easyconfigs \u00b6 --copy-ec Implementing easyblocks \u00b6 (out of scope) Hands-on exercises \u00b6 Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for TensorFlow 2.2.0. (click to show solution) eb --search TensorFlow-2.2.0","title":"8. Adding support for additional software"},{"location":"adding_support_software/#adding-support-for-additional-software","text":"","title":"Adding support for additional software"},{"location":"adding_support_software/#easyconfigs-vs-easyblocks","text":"","title":"Easyconfigs vs easyblocks"},{"location":"adding_support_software/#writing-easyconfig-files","text":"1 2 3 4 name = 'example' version = '1.2.3' toolchain = { 'name' : 'foss' , 'version' : '2019b' } graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2]","title":"Writing easyconfig files"},{"location":"adding_support_software/#mandatory-parameters","text":"","title":"Mandatory parameters"},{"location":"adding_support_software/#software-name-version","text":"","title":"Software name &amp; version"},{"location":"adding_support_software/#homepage-and-description","text":"","title":"Homepage and description"},{"location":"adding_support_software/#toolchain","text":"","title":"Toolchain"},{"location":"adding_support_software/#commonly-used-parameters","text":"","title":"Commonly used parameters"},{"location":"adding_support_software/#easyblock","text":"generic vs software-specific common generic easyblocks","title":"Easyblock"},{"location":"adding_support_software/#sources","text":"","title":"Sources"},{"location":"adding_support_software/#dependencies","text":"","title":"Dependencies"},{"location":"adding_support_software/#command-options","text":"","title":"Command options"},{"location":"adding_support_software/#sanity-check","text":"","title":"Sanity check"},{"location":"adding_support_software/#module-class","text":"","title":"Module class"},{"location":"adding_support_software/#custom-parameters","text":"eb -a --easyblock","title":"Custom parameters"},{"location":"adding_support_software/#generating-tweaked-easyconfigs","text":"--try-*","title":"Generating tweaked easyconfigs"},{"location":"adding_support_software/#copying-easyconfigs","text":"--copy-ec","title":"Copying easyconfigs"},{"location":"adding_support_software/#implementing-easyblocks","text":"(out of scope)","title":"Implementing easyblocks"},{"location":"adding_support_software/#hands-on-exercises","text":"Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for TensorFlow 2.2.0. (click to show solution) eb --search TensorFlow-2.2.0","title":"Hands-on exercises"},{"location":"adding_support_software/slides/","text":"Adding support for additional software \u00b6 A.k.a. writing your own easyconfig files.","title":"Slides"},{"location":"adding_support_software/slides/#adding-support-for-additional-software","text":"A.k.a. writing your own easyconfig files.","title":"Adding support for additional software"},{"location":"basic_usage/","text":"Basic usage \u00b6 Now we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. We will wrap things up by stepping through an example and offering a couple of exercises that will help to make you more familiar with the EasyBuild command line interface. Workflow \u00b6 Installing software with EasyBuild is as easy (hah!) as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , usually in combination with the --robot option to enable dependency resolution. It is recommended to assess the current situation before letting EasyBuild install the software, to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild and ensure that the configuration option are what you would expect, for example. Specifying easyconfigs \u00b6 Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. We will briefly cover how to install easyconfig files straight from a GitHub pull request later though (see here ). Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding option, are assumed to refer to easyconfig files. These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory ; Specified paths must of course point to an existing file; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found, then EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with ' .eb ', and use these as easyconfig files. Example command \u00b6 Suppose we have the current situation in our home directory: two (easyconfig) files named example1 and example2 ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1 example2 some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb bzip2-1.0.6.eb example1 $HOME /example2 deps EasyBuild will interpret each of these arguments as follows: bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); example1 is the name of a file in the current directory, so it can be used directly; likewise, $HOME/example2 specifies the full path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , ignoring the list.txt file since its name does not end with ' .eb '; Easyconfig filenames \u00b6 Note that the eb command does care how easyconfig files are named, at least to some extent: the ' .eb ' file extension does matter w.r.t. easyconfig files being picked up in subdirectories. File names for easyconfigs being irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb : <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ); this part (including the preceding - ) is omitted when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default); Searching for easyconfigs \u00b6 You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package, which you can do by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path you can use the search-paths configuration setting, or you can change the robot search path via either robot or robot-paths . Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for TensorFlow 2.2.0: $ eb --search tensorflow-2.2.0 * /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb This output is a bit more condensed when using eb -S : $ eb -S tensorflow-2.2.0 CFGS1=/easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/t/TensorFlow * $CFGS1/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * $CFGS1/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb Note that the search is performed case-insenstive . The search pattern can include wildcards like .* or character groups like [0-9] , but you need to be careful that bash does not expand these before the eb command is started, by wrapping the search pattern in single quotes ( '...' ). For example, to check which easyconfigs are available to install OpenFOAM with the foss/2019b toolchain: $ eb -S 'openfoam-[0-9].*foss-2019b' CFGS1=/easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/o/OpenFOAM * $CFGS1/OpenFOAM-6-foss-2019b.eb * $CFGS1/OpenFOAM-7-foss-2019b.eb Search index \u00b6 When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory, which signficantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of small files are rather slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information . Inspecting easyconfigs \u00b6 Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to copy-paste the full path to the easyconfig file, you can also use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.6.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.6' homepage = 'https://sourceware.org/bzip2' description = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/bzip2/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd' , # bzip2-1.0.6.tar.gz '5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d' , # bzip2-1.0.6-pkgconfig.patch ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. Checking dependencies \u00b6 Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \". When using the prepared container image , run this command to make the already installed software stack available: module use /easybuild/modules/all Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an intended location (like $HOME/.local/easybuild , which is the default installation path ). Dry run \u00b6 To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the dependencies that are required for SAMtools-1.10-GCC-9.3.0.eb are already installed: $ eb SAMtools-1.10-GCC-9.3.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-9.3.0.eb ( module: bzip2/1.0.8-GCCcore-9.3.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-9.3.0.eb ( module: XZ/5.2.5-GCCcore-9.3.0 ) * [ x ] $CFGS /c/cURL/cURL-7.69.1-GCCcore-9.3.0.eb ( module: cURL/7.69.1-GCCcore-9.3.0 ) * [ x ] $CFGS /g/GCC/GCC-9.3.0.eb ( module: GCC/9.3.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-9.3.0.eb ( module: ncurses/6.2-GCCcore-9.3.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb ( module: SAMtools/1.10-GCC-9.3.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.10-GCC-9.3.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by the [ ] . Missing dependencies \u00b6 If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get h5py version 2.10.0 using the 2020a version of the foss toolchain installed: $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb -M 2 out of 54 required modules missing: * pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 ( pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb ) * h5py/2.10.0-foss-2020a-Python-3.8.2 ( h5py-2.10.0-foss-2020a-Python-3.8.2.eb ) That should be pretty self-explanatory: out of the 54 required dependencies (which includes the foss toolchain and everything needed to install it), only 2 dependencies are missing. Great! Inspecting install procedures \u00b6 Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.72.0-gompi-2020a.eb : $ eb Boost-1.72.0-gompi-2020a.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load gompi/2020a Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-9.3.0 module load zlib/1.2.11-GCCcore-9.3.0 module load XZ/5.2.5-GCCcore-9.3.0 ... Defining build environment... ... export CXX = 'mpicxx' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/dev/shm/example/Boost/1.72.0/gompi-2020a/obj --without-libraries=python\" ( in /tmp/kehoste/fakehome/.local/easybuild/build/Boost/1.72.0/gompi-2020a/Boost-1.72.0 ) file written: user-config.jam ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_mpi.so * lib/libboost_system.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step and in which directory, and that a file named user-config.jam will be created as well; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occured and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless. Installing software \u00b6 Enabling dependency resolution \u00b6 Trace output \u00b6 --trace Example installation \u00b6 Using installed software \u00b6 Stacking software \u00b6 Hands-on exercises \u00b6 Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions to others before they have been discussed by the tutorial organisers. Exercise 4.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. For the easybuilders/tutorial container image ), we have installed a small software stack with the foss/2020a toolchain in /easybuild/ . Tip: use a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing TensorFlow version 2.2.0. (click to show solution) eb --search TensorFlow-2.2.0 Exercise 4.2 - Checking dependencies Check which dependencies are missing to install PETSc version 3.12.4 with the 2020a version of the foss toolchain. (click to show solution) eb --search 'PETSc-3.12.4.*foss-2020a' eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing Exercise 4.3 - Performing a dry run Inspect the installation procedure for GSL-2.6-GCC-9.3.0.eb by performing a dry run. Which binaries will EasyBuild check for to sanity check the installation? (click to show solution) eb -x GSL-2.6-GCC-9.3.0.eb Binaries: gsl-config , gsl-histogram , gsl-randist . Exercise 4.4 - Installing software Install the h5py Python package and all missing dependencies for Python 3.8.2, into /tmp/$USER/easybuild and leveraging already install software from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) eb --search 'h5py.*Python-3.8.2' module use /easybuild/modules/all eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --missing eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --robot --installpath /tmp/ $USER /easybuild Exercise 4.5 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"mytestfile.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) module use /tmp/ $USER /easybuild/modules/all module avail h5py module load h5py/2.10.0-foss-2020a-Python-3.8.2 python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' h5stat empty.hdf5","title":"4. Basic usage"},{"location":"basic_usage/#basic-usage","text":"Now we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. We will wrap things up by stepping through an example and offering a couple of exercises that will help to make you more familiar with the EasyBuild command line interface.","title":"Basic usage"},{"location":"basic_usage/#workflow","text":"Installing software with EasyBuild is as easy (hah!) as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , usually in combination with the --robot option to enable dependency resolution. It is recommended to assess the current situation before letting EasyBuild install the software, to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild and ensure that the configuration option are what you would expect, for example.","title":"Workflow"},{"location":"basic_usage/#specifying-easyconfigs","text":"Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. We will briefly cover how to install easyconfig files straight from a GitHub pull request later though (see here ). Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding option, are assumed to refer to easyconfig files. These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory ; Specified paths must of course point to an existing file; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found, then EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with ' .eb ', and use these as easyconfig files.","title":"Specifying easyconfigs"},{"location":"basic_usage/#example-command","text":"Suppose we have the current situation in our home directory: two (easyconfig) files named example1 and example2 ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1 example2 some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb bzip2-1.0.6.eb example1 $HOME /example2 deps EasyBuild will interpret each of these arguments as follows: bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); example1 is the name of a file in the current directory, so it can be used directly; likewise, $HOME/example2 specifies the full path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , ignoring the list.txt file since its name does not end with ' .eb ';","title":"Example command"},{"location":"basic_usage/#easyconfig-filenames","text":"Note that the eb command does care how easyconfig files are named, at least to some extent: the ' .eb ' file extension does matter w.r.t. easyconfig files being picked up in subdirectories. File names for easyconfigs being irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb : <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ); this part (including the preceding - ) is omitted when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default);","title":"Easyconfig filenames"},{"location":"basic_usage/#searching-for-easyconfigs","text":"You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package, which you can do by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path you can use the search-paths configuration setting, or you can change the robot search path via either robot or robot-paths . Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for TensorFlow 2.2.0: $ eb --search tensorflow-2.2.0 * /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb This output is a bit more condensed when using eb -S : $ eb -S tensorflow-2.2.0 CFGS1=/easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/t/TensorFlow * $CFGS1/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * $CFGS1/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb Note that the search is performed case-insenstive . The search pattern can include wildcards like .* or character groups like [0-9] , but you need to be careful that bash does not expand these before the eb command is started, by wrapping the search pattern in single quotes ( '...' ). For example, to check which easyconfigs are available to install OpenFOAM with the foss/2019b toolchain: $ eb -S 'openfoam-[0-9].*foss-2019b' CFGS1=/easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/o/OpenFOAM * $CFGS1/OpenFOAM-6-foss-2019b.eb * $CFGS1/OpenFOAM-7-foss-2019b.eb","title":"Searching for easyconfigs"},{"location":"basic_usage/#search-index","text":"When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory, which signficantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of small files are rather slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information .","title":"Search index"},{"location":"basic_usage/#inspecting-easyconfigs","text":"Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to copy-paste the full path to the easyconfig file, you can also use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.6.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.6' homepage = 'https://sourceware.org/bzip2' description = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/bzip2/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd' , # bzip2-1.0.6.tar.gz '5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d' , # bzip2-1.0.6-pkgconfig.patch ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed.","title":"Inspecting easyconfigs"},{"location":"basic_usage/#checking-dependencies","text":"Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \". When using the prepared container image , run this command to make the already installed software stack available: module use /easybuild/modules/all Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an intended location (like $HOME/.local/easybuild , which is the default installation path ).","title":"Checking dependencies"},{"location":"basic_usage/#dry-run","text":"To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the dependencies that are required for SAMtools-1.10-GCC-9.3.0.eb are already installed: $ eb SAMtools-1.10-GCC-9.3.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-9.3.0.eb ( module: bzip2/1.0.8-GCCcore-9.3.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-9.3.0.eb ( module: XZ/5.2.5-GCCcore-9.3.0 ) * [ x ] $CFGS /c/cURL/cURL-7.69.1-GCCcore-9.3.0.eb ( module: cURL/7.69.1-GCCcore-9.3.0 ) * [ x ] $CFGS /g/GCC/GCC-9.3.0.eb ( module: GCC/9.3.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-9.3.0.eb ( module: ncurses/6.2-GCCcore-9.3.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb ( module: SAMtools/1.10-GCC-9.3.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.10-GCC-9.3.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by the [ ] .","title":"Dry run"},{"location":"basic_usage/#missing-dependencies","text":"If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get h5py version 2.10.0 using the 2020a version of the foss toolchain installed: $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb -M 2 out of 54 required modules missing: * pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 ( pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb ) * h5py/2.10.0-foss-2020a-Python-3.8.2 ( h5py-2.10.0-foss-2020a-Python-3.8.2.eb ) That should be pretty self-explanatory: out of the 54 required dependencies (which includes the foss toolchain and everything needed to install it), only 2 dependencies are missing. Great!","title":"Missing dependencies"},{"location":"basic_usage/#inspecting-install-procedures","text":"Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.72.0-gompi-2020a.eb : $ eb Boost-1.72.0-gompi-2020a.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load gompi/2020a Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-9.3.0 module load zlib/1.2.11-GCCcore-9.3.0 module load XZ/5.2.5-GCCcore-9.3.0 ... Defining build environment... ... export CXX = 'mpicxx' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/dev/shm/example/Boost/1.72.0/gompi-2020a/obj --without-libraries=python\" ( in /tmp/kehoste/fakehome/.local/easybuild/build/Boost/1.72.0/gompi-2020a/Boost-1.72.0 ) file written: user-config.jam ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_mpi.so * lib/libboost_system.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step and in which directory, and that a file named user-config.jam will be created as well; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occured and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless.","title":"Inspecting install procedures"},{"location":"basic_usage/#installing-software","text":"","title":"Installing software"},{"location":"basic_usage/#enabling-dependency-resolution","text":"","title":"Enabling dependency resolution"},{"location":"basic_usage/#trace-output","text":"--trace","title":"Trace output"},{"location":"basic_usage/#example-installation","text":"","title":"Example installation"},{"location":"basic_usage/#using-installed-software","text":"","title":"Using installed software"},{"location":"basic_usage/#stacking-software","text":"","title":"Stacking software"},{"location":"basic_usage/#hands-on-exercises","text":"Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions to others before they have been discussed by the tutorial organisers. Exercise 4.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. For the easybuilders/tutorial container image ), we have installed a small software stack with the foss/2020a toolchain in /easybuild/ . Tip: use a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing TensorFlow version 2.2.0. (click to show solution) eb --search TensorFlow-2.2.0 Exercise 4.2 - Checking dependencies Check which dependencies are missing to install PETSc version 3.12.4 with the 2020a version of the foss toolchain. (click to show solution) eb --search 'PETSc-3.12.4.*foss-2020a' eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing Exercise 4.3 - Performing a dry run Inspect the installation procedure for GSL-2.6-GCC-9.3.0.eb by performing a dry run. Which binaries will EasyBuild check for to sanity check the installation? (click to show solution) eb -x GSL-2.6-GCC-9.3.0.eb Binaries: gsl-config , gsl-histogram , gsl-randist . Exercise 4.4 - Installing software Install the h5py Python package and all missing dependencies for Python 3.8.2, into /tmp/$USER/easybuild and leveraging already install software from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) eb --search 'h5py.*Python-3.8.2' module use /easybuild/modules/all eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --missing eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --robot --installpath /tmp/ $USER /easybuild Exercise 4.5 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"mytestfile.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) module use /tmp/ $USER /easybuild/modules/all module avail h5py module load h5py/2.10.0-foss-2020a-Python-3.8.2 python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' h5stat empty.hdf5","title":"Hands-on exercises"},{"location":"basic_usage/slides/","text":"Basic usage \u00b6 Use the eb command line, Luke.","title":"Slides"},{"location":"basic_usage/slides/#basic-usage","text":"Use the eb command line, Luke.","title":"Basic usage"},{"location":"beyond_the_basics/","text":"Beyond the basics \u00b6 Adding support for additional software \u00b6 Using a custom module naming scheme \u00b6 Multi-architecture software stacks \u00b6","title":"6. Beyond the basics"},{"location":"beyond_the_basics/#beyond-the-basics","text":"","title":"Beyond the basics"},{"location":"beyond_the_basics/#adding-support-for-additional-software","text":"","title":"Adding support for additional software"},{"location":"beyond_the_basics/#using-a-custom-module-naming-scheme","text":"","title":"Using a custom module naming scheme"},{"location":"beyond_the_basics/#multi-architecture-software-stacks","text":"","title":"Multi-architecture software stacks"},{"location":"beyond_the_basics/slides/","text":"Beyond the basics: foo \u00b6 Beyond the basics: bar \u00b6 Beyond the basics: baz \u00b6","title":"Slides"},{"location":"beyond_the_basics/slides/#beyond-the-basics-foo","text":"","title":"Beyond the basics: foo"},{"location":"beyond_the_basics/slides/#beyond-the-basics-bar","text":"","title":"Beyond the basics: bar"},{"location":"beyond_the_basics/slides/#beyond-the-basics-baz","text":"","title":"Beyond the basics: baz"},{"location":"community/","text":"","title":"11. The EasyBuild Community"},{"location":"community/slides/","text":"The EasyBuild community \u00b6 Divide & conquer.","title":"Slides"},{"location":"community/slides/#the-easybuild-community","text":"Divide & conquer.","title":"The EasyBuild community"},{"location":"comparison_other_tools/","text":"","title":"13. Comparison with other tools"},{"location":"comparison_other_tools/slides/","text":"Comparison with other tools: Spark \u00b6 Or Slack?","title":"Slides"},{"location":"comparison_other_tools/slides/#comparison-with-other-tools-spark","text":"Or Slack?","title":"Comparison with other tools: Spark"},{"location":"computecanada/","text":"","title":"10. EasyBuild at Compute Canada"},{"location":"computecanada/slides/","text":"EasyBuild at Compute Canada \u00b6 TODO: Maxime?","title":"Slides"},{"location":"computecanada/slides/#easybuild-at-compute-canada","text":"TODO: Maxime?","title":"EasyBuild at Compute Canada"},{"location":"configuration/","text":"Configuration \u00b6 After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool; if you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration and tailor it to your preferences. Note Configuring EasyBuild is also covered in detail in the EasyBuild documentation, see here . Available configuration settings \u00b6 One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases flexibility to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, over 230 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings and cover the most prominent and important ones. Note We will usually refer to configuration settings using the name as it appears in the output of eb --help , which may includes dashes ( - ). The leading ' -- ' is omitted for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details. Overall prefix \u00b6 (default: HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting. Install path \u00b6 (default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster, such that the installation can be performed on one node while being accessible on the whole cluster. Of course, software can also be installed on a local filesystem. This is particularly useful when testing and evaluating installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory and the default software and modules/all subdirectories are used. Build path \u00b6 (default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is reattempted. Running out of disk space in the location where build directories are created will result in failing installations. It is recommended to use a directory on a local filesystem for buildpath , or an in-memory filesystem like /dev/shm (if you have a significant amount of working memory available on your system). In addition, try to ensure you use a path that does not overlap with other users on the same system. So set buildpath to /tmp/$USER or /dev/shm/$USER , for example. Source path \u00b6 (default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files as well as the location to stored downloaded source files can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software packagamed ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Any additional paths can be read-only for the account running EasyBuild. Easyconfigs archive \u00b6 (default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported. More information is available in the EasyBuild documentation . For the sake of this tutorial we recommend sticking to a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting. Modules tool & module syntax \u00b6 (default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod. To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool, see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod. We recommend using EasyBuild with Lmod as modules tool and Lua as module syntax. Robot search path \u00b6 (default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between both is that setting robot also enables dependency resolution and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files, while defining robot-paths does not have this side effect. In addition, you can use the --robot command line option without specifying any paths to it to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered. There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation . Module naming scheme \u00b6 (default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes ). The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional labels (which corresponds to value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Note Using a different module naming scheme is largely out of scope for this tutorial, except when covering hierarchical module naming schemes . Configuration levels \u00b6 Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception! Configuration level hierarchy \u00b6 There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always * win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named -magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ). is not defined and if the ---magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead; Configuration files \u00b6 Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing. EasyBuild configuration files vs easyconfig files \u00b6 EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. Hopefully this helps to avoid the confusion... $EASYBUILD_* environment variables \u00b6 A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ). eb command line options \u00b6 Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use a command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ); although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would be less than useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb Inspecting the current configuration ( --show-config ) \u00b6 Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Therefore, the --show-config command line option is provided to easily inspect the currently active EasyBuild configuration. The output includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produces by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user : # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ) and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Now let us do some basic configuring and inspect the resulting output of --show-config : $ export EASYBUILD_PREFIX = $HOME /easybuild $ export EASYBUILD_BUILDPATH = /dev/shm/ $USER $ eb --installpath = /tmp/ $USER --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /dev/shm/example containerpath ( E ) = /home/example/easybuild/containers installpath ( C ) = /tmp/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources The output indicates that the installpath setting was specified through a command line option (indicated with ' (C) '), that the robot-paths setting still has the default values, and that all other configuration settings were specified via an environment variable (some of which indirectly through the prefix value). Warning Make sure you have EasyBuild properly configured before you proceed with the rest of the tutorial!","title":"3. Configuration"},{"location":"configuration/#configuration","text":"After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool; if you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration and tailor it to your preferences. Note Configuring EasyBuild is also covered in detail in the EasyBuild documentation, see here .","title":"Configuration"},{"location":"configuration/#available-configuration-settings","text":"One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases flexibility to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, over 230 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings and cover the most prominent and important ones. Note We will usually refer to configuration settings using the name as it appears in the output of eb --help , which may includes dashes ( - ). The leading ' -- ' is omitted for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details.","title":"Available configuration settings"},{"location":"configuration/#overall-prefix","text":"(default: HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting.","title":"Overall prefix"},{"location":"configuration/#install-path","text":"(default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster, such that the installation can be performed on one node while being accessible on the whole cluster. Of course, software can also be installed on a local filesystem. This is particularly useful when testing and evaluating installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory and the default software and modules/all subdirectories are used.","title":"Install path"},{"location":"configuration/#build-path","text":"(default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is reattempted. Running out of disk space in the location where build directories are created will result in failing installations. It is recommended to use a directory on a local filesystem for buildpath , or an in-memory filesystem like /dev/shm (if you have a significant amount of working memory available on your system). In addition, try to ensure you use a path that does not overlap with other users on the same system. So set buildpath to /tmp/$USER or /dev/shm/$USER , for example.","title":"Build path"},{"location":"configuration/#source-path","text":"(default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files as well as the location to stored downloaded source files can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software packagamed ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Any additional paths can be read-only for the account running EasyBuild.","title":"Source path"},{"location":"configuration/#easyconfigs-archive","text":"(default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported. More information is available in the EasyBuild documentation . For the sake of this tutorial we recommend sticking to a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting.","title":"Easyconfigs archive"},{"location":"configuration/#modules-tool-module-syntax","text":"(default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod. To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool, see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod. We recommend using EasyBuild with Lmod as modules tool and Lua as module syntax.","title":"Modules tool &amp; module syntax"},{"location":"configuration/#robot-search-path","text":"(default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between both is that setting robot also enables dependency resolution and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files, while defining robot-paths does not have this side effect. In addition, you can use the --robot command line option without specifying any paths to it to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered. There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation .","title":"Robot search path"},{"location":"configuration/#module-naming-scheme","text":"(default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes ). The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional labels (which corresponds to value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Note Using a different module naming scheme is largely out of scope for this tutorial, except when covering hierarchical module naming schemes .","title":"Module naming scheme"},{"location":"configuration/#configuration-levels","text":"Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception!","title":"Configuration levels"},{"location":"configuration/#configuration-level-hierarchy","text":"There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always * win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named -magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ). is not defined and if the ---magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead;","title":"Configuration level hierarchy"},{"location":"configuration/#configuration-files","text":"Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.","title":"Configuration files"},{"location":"configuration/#easybuild-configuration-files-vs-easyconfig-files","text":"EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. Hopefully this helps to avoid the confusion...","title":"EasyBuild configuration files vs easyconfig files"},{"location":"configuration/#easybuild_-environment-variables","text":"A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ).","title":"$EASYBUILD_* environment variables"},{"location":"configuration/#eb-command-line-options","text":"Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use a command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ); although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would be less than useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb","title":"eb command line options"},{"location":"configuration/#inspecting-the-current-configuration-show-config","text":"Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Therefore, the --show-config command line option is provided to easily inspect the currently active EasyBuild configuration. The output includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produces by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user : # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ) and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Now let us do some basic configuring and inspect the resulting output of --show-config : $ export EASYBUILD_PREFIX = $HOME /easybuild $ export EASYBUILD_BUILDPATH = /dev/shm/ $USER $ eb --installpath = /tmp/ $USER --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /dev/shm/example containerpath ( E ) = /home/example/easybuild/containers installpath ( C ) = /tmp/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources The output indicates that the installpath setting was specified through a command line option (indicated with ' (C) '), that the robot-paths setting still has the default values, and that all other configuration settings were specified via an environment variable (some of which indirectly through the prefix value). Warning Make sure you have EasyBuild properly configured before you proceed with the rest of the tutorial!","title":"Inspecting the current configuration (--show-config)"},{"location":"configuration/slides/","text":"Configuration \u00b6 (coming soon)","title":"Slides"},{"location":"configuration/slides/#configuration","text":"(coming soon)","title":"Configuration"},{"location":"contributing/","text":"Contributing to EasyBuild \u00b6 Github integration features \u00b6 Using easyconfigs from a PR \u00b6 --from-pr Note: we link to this section from the \"Basic usage\" part!","title":"12. Contributing to EasyBuild"},{"location":"contributing/#contributing-to-easybuild","text":"","title":"Contributing to EasyBuild"},{"location":"contributing/#github-integration-features","text":"","title":"Github integration features"},{"location":"contributing/#using-easyconfigs-from-a-pr","text":"--from-pr Note: we link to this section from the \"Basic usage\" part!","title":"Using easyconfigs from a PR"},{"location":"contributing/slides/","text":"Contributing to EasyBuild \u00b6 You know you want to.","title":"Slides"},{"location":"contributing/slides/#contributing-to-easybuild","text":"You know you want to.","title":"Contributing to EasyBuild"},{"location":"getting_help/","text":"","title":"14. Getting help"},{"location":"getting_help/slides/","text":"Getting help \u00b6 mailing list GitHub issues Slack","title":"Slides"},{"location":"getting_help/slides/#getting-help","text":"mailing list GitHub issues Slack","title":"Getting help"},{"location":"hmns/","text":"Hierarchical module naming schemes \u00b6 Flat vs hierarchical \u00b6 Procs & cons \u00b6","title":"7. Hierarchical module naming schemes"},{"location":"hmns/#hierarchical-module-naming-schemes","text":"","title":"Hierarchical module naming schemes"},{"location":"hmns/#flat-vs-hierarchical","text":"","title":"Flat vs hierarchical"},{"location":"hmns/#procs-cons","text":"","title":"Procs &amp; cons"},{"location":"hmns/slides/","text":"Hierarchical module naming schemes \u00b6 Or HMNS for short.","title":"Slides"},{"location":"hmns/slides/#hierarchical-module-naming-schemes","text":"Or HMNS for short.","title":"Hierarchical module naming schemes"},{"location":"installation/","text":"Installation \u00b6 Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing so, and the things you should pay attention to. By the end of it, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended) installation methods: pip install easybuild bootstrapping EasyBuild verify EasyBuild installation using eb --version and eb --help Requirements \u00b6 Linux \u00b6 The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like contributing back to the project. Python \u00b6 EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later. Environment modules tool \u00b6 An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information. EasyBuild as a Python package \u00b6 EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve! Python 2 or Python 3? \u00b6 For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed. For more information, see the EasyBuild documentation . Installing EasyBuild \u00b6 We present two methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty! Method 1: Using pip (recommended) \u00b6 Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild. Running pip install \u00b6 Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). Updating your environment \u00b6 If you used the --user or --prefix option in the pip install command, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory ( .bashrc for example). $PATH Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). $PYTHONPATH If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 2.7, make sure you are using ' python2.7 ' in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH Method 2: Bootstrapping EasyBuild \u00b6 Note This section covers an alternative installation method. If you already have EasyBuild installed, you can skip ahead to the next section . If pip is not available or if the installation with pip is not working out for some reason, you can resort to using the bootstrapping procedure for installing EasyBuild . In essence, the bootstrap script installs EasyBuild into a temporary location and then uses this temporary EasyBuild installation to install EasyBuild into the specified directory and provide a module for it. Step 1: Downloading the bootstrap script \u00b6 First, download the latest version of the EasyBuild bootstrap script from GitHub. A common way to do this is by running this curl command: curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py Step 2: Running the bootstrap script \u00b6 To install EasyBuild using the bootstrap script simply run it using the python command and specify the installation prefix as an argument: python bootstrap_eb.py _PREFIX_ Replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). Step 3: Loading the EasyBuild module \u00b6 Once the bootstrap procedure completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' in the same way as you did when running the bootstrap script. Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note No output will be generated by either of these module commands. That is expected behaviour and completely normal. Verifying the installation \u00b6 Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation: Checking the version \u00b6 To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version . Consulting the help output \u00b6 You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help Showing the default EasyBuild configuration \u00b6 To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial. Updating EasyBuild \u00b6 Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. Warning Make sure you have EasyBuild installed before you proceed with the rest of the tutorial!","title":"2. Installation"},{"location":"installation/#installation","text":"Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing so, and the things you should pay attention to. By the end of it, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended) installation methods: pip install easybuild bootstrapping EasyBuild verify EasyBuild installation using eb --version and eb --help","title":"Installation"},{"location":"installation/#requirements","text":"","title":"Requirements"},{"location":"installation/#linux","text":"The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like contributing back to the project.","title":"Linux"},{"location":"installation/#python","text":"EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later.","title":"Python"},{"location":"installation/#environment-modules-tool","text":"An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.","title":"Environment modules tool"},{"location":"installation/#easybuild-as-a-python-package","text":"EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!","title":"EasyBuild as a Python package"},{"location":"installation/#python-2-or-python-3","text":"For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed. For more information, see the EasyBuild documentation .","title":"Python 2 or Python 3?"},{"location":"installation/#installing-easybuild","text":"We present two methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty!","title":"Installing EasyBuild"},{"location":"installation/#method-1-using-pip-recommended","text":"Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild.","title":"Method 1: Using pip (recommended)"},{"location":"installation/#running-pip-install","text":"Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Running pip install"},{"location":"installation/#updating-your-environment","text":"If you used the --user or --prefix option in the pip install command, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory ( .bashrc for example). $PATH Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). $PYTHONPATH If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 2.7, make sure you are using ' python2.7 ' in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH","title":"Updating your environment"},{"location":"installation/#method-2-bootstrapping-easybuild","text":"Note This section covers an alternative installation method. If you already have EasyBuild installed, you can skip ahead to the next section . If pip is not available or if the installation with pip is not working out for some reason, you can resort to using the bootstrapping procedure for installing EasyBuild . In essence, the bootstrap script installs EasyBuild into a temporary location and then uses this temporary EasyBuild installation to install EasyBuild into the specified directory and provide a module for it.","title":"Method 2: Bootstrapping EasyBuild"},{"location":"installation/#step-1-downloading-the-bootstrap-script","text":"First, download the latest version of the EasyBuild bootstrap script from GitHub. A common way to do this is by running this curl command: curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py","title":"Step 1: Downloading the bootstrap script"},{"location":"installation/#step-2-running-the-bootstrap-script","text":"To install EasyBuild using the bootstrap script simply run it using the python command and specify the installation prefix as an argument: python bootstrap_eb.py _PREFIX_ Replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Step 2: Running the bootstrap script"},{"location":"installation/#step-3-loading-the-easybuild-module","text":"Once the bootstrap procedure completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' in the same way as you did when running the bootstrap script. Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note No output will be generated by either of these module commands. That is expected behaviour and completely normal.","title":"Step 3: Loading the EasyBuild module"},{"location":"installation/#verifying-the-installation","text":"Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:","title":"Verifying the installation"},{"location":"installation/#checking-the-version","text":"To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version .","title":"Checking the version"},{"location":"installation/#consulting-the-help-output","text":"You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help","title":"Consulting the help output"},{"location":"installation/#showing-the-default-easybuild-configuration","text":"To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial.","title":"Showing the default EasyBuild configuration"},{"location":"installation/#updating-easybuild","text":"Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. Warning Make sure you have EasyBuild installed before you proceed with the rest of the tutorial!","title":"Updating EasyBuild"},{"location":"installation/slides/","text":"Installation \u00b6 To install EasyBuild: pip install --prefix $HOME /tools easybuild export PATH = $HOME /tools/bin: $PATH export PYTHONPATH = $HOME /tools/lib/python2.7/site-packages: $PYTHONPATH","title":"Slides"},{"location":"installation/slides/#installation","text":"To install EasyBuild: pip install --prefix $HOME /tools easybuild export PATH = $HOME /tools/bin: $PATH export PYTHONPATH = $HOME /tools/lib/python2.7/site-packages: $PYTHONPATH","title":"Installation"},{"location":"introduction/","text":"Introduction \u00b6 What is EasyBuild? \u00b6 EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromises on performance. Easybuild is especially tailored towards High Performance Computing (HPC) environments. Elevator pitch \u00b6 EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown out to be a platform for collaboration with HPC sites worldwide. Key features \u00b6 EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. It is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations if required. The installation procedure executed by EasyBuild is thoroughly logged and fully transparent via dry run and tracing . EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers (Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. The project is actively developed by a worldwide community, with stable versions being released every 6-8 weeks since 2012. Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment, consistent testing of incoming contributions, and thorough regression testing before every release. What EasyBuild is not \u00b6 EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package manangers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, Infiniband, GPU drivers, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is *not a magic solution to all your (software installation) problems . You may, and probably will still occasionally, run into compiler errors unless somebody has already taken care of the problem for you. Implementation \u00b6 EasyBuild is implemented in Python , and fully supports both Python 2.7 and 3.5+. Releases are published via PyPI , under the GPLv2 open source license . Development is done through the easybuilders organisation on GitHub , where each of the EasyBuild components is hosted in a separate repository. Terminology \u00b6 Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms. Framework \u00b6 The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.tools , etc.) that collectively form the heart of EasyBuild . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this (see easyblocks ). Easyblocks \u00b6 An easyblock is a Python module that implements a specific software installation procedure . It can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters (see easyconfig files ). Easyconfig files \u00b6 Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . They define the different easyconfig parameters that collectively form a complete specification for a particular software installation. Some easyconfig parameters are mandatory . The following parameters must be defined in each easyconfig file: name and version , which specify the name and version of the software to install (surprise!); homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains tab); Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock . Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify (drum roll...) the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If these parameters are not provided, the corresponding default value will be used. Extensions \u00b6 Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Examples are Python packages , R libraries and Perl modules . As you can tell the common terminology here is a mess, so we came up with a unifying term... Extensions can be installed in different ways: stand-alone, as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation); Dependencies \u00b6 A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of dependencies for computer software: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software; a runtime dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package; a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed; The distinction between link-time and build/runtime dependencies is irrelevant for this tutorial. Toolchains \u00b6 A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries). System toolchain \u00b6 The system toolchain is a special case which corresponds to using the system-provided compilers and libraries, rather than using toolchain components that were installed using EasyBuild. It used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system tools and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation. Modules \u00b6 Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slighty different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. EasyBuild heavily relies on environment modules, and hence having a modules tool installed is a strict requirement in order to use EasyBuild . Both Lmod and the Tcl-based Environment Modules tools are supported by EasyBuild, as well as module files in both Tcl and Lua syntax. Module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used. Bringing it all together \u00b6 The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files . EasyBuild ensures that the specified dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software. Focus points \u00b6 EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made. Performance \u00b6 EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour may be changed via the --optarch configuration setting . Reproducibility \u00b6 In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular toolchain , with which we aim to take control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild. Community effort \u00b6 In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the EasyBuild framework , easyblocks , easyconfigs repositories, or to the EasyBuild documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency. The EasyBuild community \u00b6 EasyBuild was originally created by the HPC team at Ghent University (Belgium) in 2009, and was developed in-house before it was publicly released in 2012. Since then it has grown out to a community project , which is used and developed by various HPC centres and consortia worldwide, including (but not limited to): Flemish Supercomputer Centre (VSC), Belgium Consortium des \u00c9quipements de Calcul Intensif (C\u00c9CI), Belgium J\u00fclich Supercomputing Centre (JSC), Germany Swiss National Supercomputing Centre (CSCS) Birmingham Environment for Academic Research (BEAR), UK SURFsara, Netherlands Swedish National Infrastructure for Computing (SNIC) Compute Canada Fred Hutchinson Cancer Research Center, US Texas A&M University (TAMU) High Performance Research Computing (HPRC), US National University of Singapore (NUS) University of Melbourne, Australia HPCNow! Today, an experienced team of HPC experts actively maintains the project, by implementing additional features and bug fixes, and processing incoming contributions. The EasyBuild documentation is available at https://easybuild.readthedocs.io . You can interact with the EasyBuild community via the Slack channel (request an invitation here ), or by subscribing to the mailing list .","title":"1. Introduction"},{"location":"introduction/#introduction","text":"","title":"Introduction"},{"location":"introduction/#what-is-easybuild","text":"EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromises on performance. Easybuild is especially tailored towards High Performance Computing (HPC) environments.","title":"What is EasyBuild?"},{"location":"introduction/#elevator-pitch","text":"EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown out to be a platform for collaboration with HPC sites worldwide.","title":"Elevator pitch"},{"location":"introduction/#key-features","text":"EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. It is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations if required. The installation procedure executed by EasyBuild is thoroughly logged and fully transparent via dry run and tracing . EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers (Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. The project is actively developed by a worldwide community, with stable versions being released every 6-8 weeks since 2012. Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment, consistent testing of incoming contributions, and thorough regression testing before every release.","title":"Key features"},{"location":"introduction/#what-easybuild-is-not","text":"EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package manangers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, Infiniband, GPU drivers, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is *not a magic solution to all your (software installation) problems . You may, and probably will still occasionally, run into compiler errors unless somebody has already taken care of the problem for you.","title":"What EasyBuild is not"},{"location":"introduction/#implementation","text":"EasyBuild is implemented in Python , and fully supports both Python 2.7 and 3.5+. Releases are published via PyPI , under the GPLv2 open source license . Development is done through the easybuilders organisation on GitHub , where each of the EasyBuild components is hosted in a separate repository.","title":"Implementation"},{"location":"introduction/#terminology","text":"Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms.","title":"Terminology"},{"location":"introduction/#framework","text":"The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.tools , etc.) that collectively form the heart of EasyBuild . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this (see easyblocks ).","title":"Framework"},{"location":"introduction/#easyblocks","text":"An easyblock is a Python module that implements a specific software installation procedure . It can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters (see easyconfig files ).","title":"Easyblocks"},{"location":"introduction/#easyconfig-files","text":"Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . They define the different easyconfig parameters that collectively form a complete specification for a particular software installation. Some easyconfig parameters are mandatory . The following parameters must be defined in each easyconfig file: name and version , which specify the name and version of the software to install (surprise!); homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains tab); Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock . Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify (drum roll...) the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If these parameters are not provided, the corresponding default value will be used.","title":"Easyconfig files"},{"location":"introduction/#extensions","text":"Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Examples are Python packages , R libraries and Perl modules . As you can tell the common terminology here is a mess, so we came up with a unifying term... Extensions can be installed in different ways: stand-alone, as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation);","title":"Extensions"},{"location":"introduction/#dependencies","text":"A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of dependencies for computer software: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software; a runtime dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package; a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed; The distinction between link-time and build/runtime dependencies is irrelevant for this tutorial.","title":"Dependencies"},{"location":"introduction/#toolchains","text":"A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).","title":"Toolchains"},{"location":"introduction/#system-toolchain","text":"The system toolchain is a special case which corresponds to using the system-provided compilers and libraries, rather than using toolchain components that were installed using EasyBuild. It used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system tools and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation.","title":"System toolchain"},{"location":"introduction/#modules","text":"Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slighty different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. EasyBuild heavily relies on environment modules, and hence having a modules tool installed is a strict requirement in order to use EasyBuild . Both Lmod and the Tcl-based Environment Modules tools are supported by EasyBuild, as well as module files in both Tcl and Lua syntax. Module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.","title":"Modules"},{"location":"introduction/#bringing-it-all-together","text":"The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files . EasyBuild ensures that the specified dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software.","title":"Bringing it all together"},{"location":"introduction/#focus-points","text":"EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made.","title":"Focus points"},{"location":"introduction/#performance","text":"EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour may be changed via the --optarch configuration setting .","title":"Performance"},{"location":"introduction/#reproducibility","text":"In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular toolchain , with which we aim to take control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.","title":"Reproducibility"},{"location":"introduction/#community-effort","text":"In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the EasyBuild framework , easyblocks , easyconfigs repositories, or to the EasyBuild documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.","title":"Community effort"},{"location":"introduction/#the-easybuild-community","text":"EasyBuild was originally created by the HPC team at Ghent University (Belgium) in 2009, and was developed in-house before it was publicly released in 2012. Since then it has grown out to a community project , which is used and developed by various HPC centres and consortia worldwide, including (but not limited to): Flemish Supercomputer Centre (VSC), Belgium Consortium des \u00c9quipements de Calcul Intensif (C\u00c9CI), Belgium J\u00fclich Supercomputing Centre (JSC), Germany Swiss National Supercomputing Centre (CSCS) Birmingham Environment for Academic Research (BEAR), UK SURFsara, Netherlands Swedish National Infrastructure for Computing (SNIC) Compute Canada Fred Hutchinson Cancer Research Center, US Texas A&M University (TAMU) High Performance Research Computing (HPRC), US National University of Singapore (NUS) University of Melbourne, Australia HPCNow! Today, an experienced team of HPC experts actively maintains the project, by implementing additional features and bug fixes, and processing incoming contributions. The EasyBuild documentation is available at https://easybuild.readthedocs.io . You can interact with the EasyBuild community via the Slack channel (request an invitation here ), or by subscribing to the mailing list .","title":"The EasyBuild community"},{"location":"introduction/slides/","text":"Introducing EasyBuild (slide 1) \u00b6 foo bar Introducing EasyBuild (slide 2) \u00b6 blah blah","title":"Slides"},{"location":"introduction/slides/#introducing-easybuild-slide-1","text":"foo bar","title":"Introducing EasyBuild (slide 1)"},{"location":"introduction/slides/#introducing-easybuild-slide-2","text":"blah blah","title":"Introducing EasyBuild (slide 2)"},{"location":"jsc/","text":"","title":"9. EasyBuild at J\u00fclich Supercomputing Centre"},{"location":"jsc/slides/","text":"EasyBuild at J\u00fclich Supercomputing Centre (JSC) \u00b6 TODO: Alan O'Cais","title":"Slides"},{"location":"jsc/slides/#easybuild-at-julich-supercomputing-centre-jsc","text":"TODO: Alan O'Cais","title":"EasyBuild at J\u00fclich Supercomputing Centre (JSC)"},{"location":"practical_information/","text":"Practical information \u00b6 Below you can find practical information on the provided resources for this tutorial. Slack \u00b6 There is a dedicated #tutorial channel in the EasyBuild Slack to get in touch with the tutorial organisers, where you can ask questions throughout the tutorial, or ask for help if needed. To connect, you will need to create an account in the EasyBuild Slack first, which you can do via https://easybuild-slack.herokuapp.com/ . Once you have an account, you can join the EasyBuild Slack via https://easybuild.slack.com/ , and then join the #tutorial channel. AWS resources \u00b6 (only available during the tutorial on Tuesday June 23rd 2020) Access to a shell environment on AWS Cloud9 is provided for this tutorial. You should have received an email with connection information if you have registered in time for this tutorial. If you did not register and would still like to use AWS Cloud9 for this tutorial, please contact the tutorial organisers via Slack. Prepared container image \u00b6 For the purpose of this tutorial, we have prepared a Docker container that you can use to follow the hands-on exercises in a controlled environment. This container image includes a small software stack that was installed using EasyBuild, which will come in useful for some of the exercises. The container is available through the easybuilders/tutorial repository on Docker Hub , and can be used with both Docker and Singularity. Requirements for using the container images \u00b6 (only relevant if you are not using AWS Cloud9) having Docker or Singularity installed a system with a processor compatible with software built for Intel Haswell (AVX2) Container size \u00b6 The compressed container image is about 1.1GB in size, and will be downloaded automatically from Docker Hub when you run the docker or singularity command shown below. Using Docker \u00b6 If you want to use the prepared container image via Docker, run the following docker command: docker run -ti --hostname tutorial --rm easybuilders/tutorial:isc20-haswell Using Singularity \u00b6 (not available in AWS environment) To use the prepared container image via Singularity, run the following singularity command: mkdir -p /tmp/ $USER /isc20 singularity run --cleanenv --home /tmp/ $USER /isc20 docker://easybuilders/tutorial:isc20-haswell The additional options are required to: --cleanenv : start with clean environment --home /tmp/$USER/isc20 : use (empty) /tmp/$USER/isc20 directory as home directory in container This is mainly to avoid that anything from the host environment or your home directory \"leaks\" into the container, which could interfere with the hands-on exercises. Singularity cache \u00b6 By default Singularity keeps its cache at $HOME/.singularity/cache . Since the uncompressed container image requires about 2.2GB of disk space, make sure this will work in your setup. If your home directory is limited in size you can either make $HOME/.singularity as symbolic link to /tmp/$USER/singularity for example, or define the $SINGULARITY_CACHEDIR environment variable to make Singulartiy use a different location: export SINGULARITY_CACHEDIR = /tmp/ $USER /singularity Warning messages \u00b6 When running the Docker container with Singularity, you may see a bunch of warning messages like this pass by: warn rootless{path/to/file} ignoring (usually) harmless EPERM on setxattr \"user.rootlesscontainers\" You can safely ignore these warnings, they are harmless. They occur because the Docker container image contains xattrs that can not be set when the container is extracted as an unpriviledged user by Singularity. The warnings are generated by the umoci library that Singularity uses to extract Docker/OCI layers, and is documented at https://umo.ci/quick-start/rootless/ . Welcome message \u00b6 If you are correctly logged in to the container, you should see a message like this: You are logged in to the prepared environment for the introductory tutorial to ______ ____ _ _ _ | ____| | _ \\ (_)| | | | | |__ __ _ ___ _ _ | |_) | _ _ _ | | __| | | __| / _` |/ __|| | | || _ < | | | || || | / _` | | |____| (_| |\\__ \\| |_| || |_) || |_| || || || (_| | |______|\\__,_||___/ \\__, ||____/ \\__,_||_||_| \\__,_| __/ | |___/ The tutorial materials are available at https://easybuilders.github.io/easybuild-tutorial . OS: CentOS Linux release 7.8.2003 (Core) modules tool: Lmod 8.2.7 To access the pre-installed software run 'module use /easybuild/modules/all', and then check which modules are installed using 'module avail'. In case of questions or problems contact the tutorial organisers via the #tutorial channel in the EasyBuild Slack, join via https://easybuild-slack.herokuapp.com . Testing host compatibility \u00b6 To leverage the pre-installed software stack that is included in the container image, the processor in your system must be compatible with binaries that use AVX2 instructions (Intel Haswell generation, or newer). You can test the compatibility of your host with the following commands: module use /easybuild/modules/all module load Python python -V If the last command prints a Python version (like Python 3.8.2 ), then your host is compatible. If you see a message like \" Illegal instruction (core dumped) \", the processor in your system is not compatible with the pre-installed software stack.","title":"0. Practical information"},{"location":"practical_information/#practical-information","text":"Below you can find practical information on the provided resources for this tutorial.","title":"Practical information"},{"location":"practical_information/#slack","text":"There is a dedicated #tutorial channel in the EasyBuild Slack to get in touch with the tutorial organisers, where you can ask questions throughout the tutorial, or ask for help if needed. To connect, you will need to create an account in the EasyBuild Slack first, which you can do via https://easybuild-slack.herokuapp.com/ . Once you have an account, you can join the EasyBuild Slack via https://easybuild.slack.com/ , and then join the #tutorial channel.","title":"Slack"},{"location":"practical_information/#aws-resources","text":"(only available during the tutorial on Tuesday June 23rd 2020) Access to a shell environment on AWS Cloud9 is provided for this tutorial. You should have received an email with connection information if you have registered in time for this tutorial. If you did not register and would still like to use AWS Cloud9 for this tutorial, please contact the tutorial organisers via Slack.","title":"AWS resources"},{"location":"practical_information/#prepared-container-image","text":"For the purpose of this tutorial, we have prepared a Docker container that you can use to follow the hands-on exercises in a controlled environment. This container image includes a small software stack that was installed using EasyBuild, which will come in useful for some of the exercises. The container is available through the easybuilders/tutorial repository on Docker Hub , and can be used with both Docker and Singularity.","title":"Prepared container image"},{"location":"practical_information/#requirements-for-using-the-container-images","text":"(only relevant if you are not using AWS Cloud9) having Docker or Singularity installed a system with a processor compatible with software built for Intel Haswell (AVX2)","title":"Requirements for using the container images"},{"location":"practical_information/#container-size","text":"The compressed container image is about 1.1GB in size, and will be downloaded automatically from Docker Hub when you run the docker or singularity command shown below.","title":"Container size"},{"location":"practical_information/#using-docker","text":"If you want to use the prepared container image via Docker, run the following docker command: docker run -ti --hostname tutorial --rm easybuilders/tutorial:isc20-haswell","title":"Using Docker"},{"location":"practical_information/#using-singularity","text":"(not available in AWS environment) To use the prepared container image via Singularity, run the following singularity command: mkdir -p /tmp/ $USER /isc20 singularity run --cleanenv --home /tmp/ $USER /isc20 docker://easybuilders/tutorial:isc20-haswell The additional options are required to: --cleanenv : start with clean environment --home /tmp/$USER/isc20 : use (empty) /tmp/$USER/isc20 directory as home directory in container This is mainly to avoid that anything from the host environment or your home directory \"leaks\" into the container, which could interfere with the hands-on exercises.","title":"Using Singularity"},{"location":"practical_information/#singularity-cache","text":"By default Singularity keeps its cache at $HOME/.singularity/cache . Since the uncompressed container image requires about 2.2GB of disk space, make sure this will work in your setup. If your home directory is limited in size you can either make $HOME/.singularity as symbolic link to /tmp/$USER/singularity for example, or define the $SINGULARITY_CACHEDIR environment variable to make Singulartiy use a different location: export SINGULARITY_CACHEDIR = /tmp/ $USER /singularity","title":"Singularity cache"},{"location":"practical_information/#warning-messages","text":"When running the Docker container with Singularity, you may see a bunch of warning messages like this pass by: warn rootless{path/to/file} ignoring (usually) harmless EPERM on setxattr \"user.rootlesscontainers\" You can safely ignore these warnings, they are harmless. They occur because the Docker container image contains xattrs that can not be set when the container is extracted as an unpriviledged user by Singularity. The warnings are generated by the umoci library that Singularity uses to extract Docker/OCI layers, and is documented at https://umo.ci/quick-start/rootless/ .","title":"Warning messages"},{"location":"practical_information/#welcome-message","text":"If you are correctly logged in to the container, you should see a message like this: You are logged in to the prepared environment for the introductory tutorial to ______ ____ _ _ _ | ____| | _ \\ (_)| | | | | |__ __ _ ___ _ _ | |_) | _ _ _ | | __| | | __| / _` |/ __|| | | || _ < | | | || || | / _` | | |____| (_| |\\__ \\| |_| || |_) || |_| || || || (_| | |______|\\__,_||___/ \\__, ||____/ \\__,_||_||_| \\__,_| __/ | |___/ The tutorial materials are available at https://easybuilders.github.io/easybuild-tutorial . OS: CentOS Linux release 7.8.2003 (Core) modules tool: Lmod 8.2.7 To access the pre-installed software run 'module use /easybuild/modules/all', and then check which modules are installed using 'module avail'. In case of questions or problems contact the tutorial organisers via the #tutorial channel in the EasyBuild Slack, join via https://easybuild-slack.herokuapp.com .","title":"Welcome message"},{"location":"practical_information/#testing-host-compatibility","text":"To leverage the pre-installed software stack that is included in the container image, the processor in your system must be compatible with binaries that use AVX2 instructions (Intel Haswell generation, or newer). You can test the compatibility of your host with the following commands: module use /easybuild/modules/all module load Python python -V If the last command prints a Python version (like Python 3.8.2 ), then your host is compatible. If you see a message like \" Illegal instruction (core dumped) \", the processor in your system is not compatible with the pre-installed software stack.","title":"Testing host compatibility"},{"location":"troubleshooting/","text":"Troubleshooting \u00b6 Inspecting the build directory \u00b6 Navigating log files \u00b6 Common patterns for error messages \u00b6","title":"5. Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#inspecting-the-build-directory","text":"","title":"Inspecting the build directory"},{"location":"troubleshooting/#navigating-log-files","text":"","title":"Navigating log files"},{"location":"troubleshooting/#common-patterns-for-error-messages","text":"","title":"Common patterns for error messages"},{"location":"troubleshooting/slides/","text":"Troubleshooting \u00b6 In trouble, huh?","title":"Slides"},{"location":"troubleshooting/slides/#troubleshooting","text":"In trouble, huh?","title":"Troubleshooting"}]}